<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Isolation Forest – Models</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-650962646ede98a6f0d577bcd0196704.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Models</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Isolation Forest</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Model</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p><strong>Read this</strong> - Do <strong>not</strong> add or remove Python libraries. Stick to the imports already present in this notebook. Changing libraries is an automatic <strong>−100%</strong>. - You may use <strong>machine learning, statistics, or a hybrid</strong> approach — but your method must generalize to <strong>new, unseen datasets</strong>. - Datasets: We have 10 time-series with <strong>10 000 rows</strong> each; anomalies: <strong>10 segments per dataset</strong>. You can upload the zip to you Google drive and use the ID from Google drive url. - Scoring in class: we will run your detector on <strong>novel datasets</strong>. <strong>#correct/10 × 100</strong> is your percentage. - Over/under-fitting penalties may apply (<strong>−50%</strong>).</p>
<section id="what-you-must-do" class="level1">
<h1>What you must do</h1>
<p>Implement your anomaly detector using any means (could it be Machine Learning or statistics or a combination of both to improve the accuracy of the model). Return the index ranges for the anomalies for example 2001-2010.</p>
<p>You can also add small EDA (plots/stats) in the <strong>EDA cell</strong> below to justify your approach.</p>
<p><strong>Do not modify</strong> existing data loading and the libraries.</p>
</section>
<section id="the-anomaly-detection-notebook" class="level1">
<h1><strong>The Anomaly Detection Notebook</strong></h1>
<div id="a9107835" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:206}}" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> os</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>train_file_names <span class="op">=</span> os.listdir(<span class="st">"train/"</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>train_file_names.sort()</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>train_files <span class="op">=</span> []</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="bu">file</span> <span class="kw">in</span> train_file_names:</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    train_files.append(pd.read_csv(<span class="ss">f"train/</span><span class="sc">{</span><span class="bu">file</span><span class="sc">}</span><span class="ss">"</span>, sep<span class="op">=</span><span class="st">";"</span>))</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>test_file_names <span class="op">=</span> os.listdir(<span class="st">"test/"</span>)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>test_file_names.sort()</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>test_files <span class="op">=</span> []</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="bu">file</span> <span class="kw">in</span> test_file_names:</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    test_files.append(pd.read_csv(<span class="ss">f"test/</span><span class="sc">{</span><span class="bu">file</span><span class="sc">}</span><span class="ss">"</span>, sep<span class="op">=</span><span class="st">";"</span>))</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>test_files[<span class="dv">0</span>].head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Value1</th>
<th data-quarto-table-cell-role="th">Labels</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>20.801402</td>
<td>0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>26.800208</td>
<td>0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>33.154527</td>
<td>0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>39.189824</td>
<td>0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>40.631321</td>
<td>0</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<section id="student-eda" class="level2">
<h2 class="anchored" data-anchor-id="student-eda">Student EDA</h2>
<p>Use this cell to explore the signal (e.g., plot, summary stats).</p>
<div id="7a1e726b" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># STUDENT EDA</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> test_files[<span class="dv">0</span>]</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(df.head())</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'EDA note: run the original data-loading cells first (the ones that populate train_files/test_files).'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      Value1  Labels
0  20.801402       0
1  26.800208       0
2  33.154527       0
3  39.189824       0
4  40.631321       0</code></pre>
</div>
</div>
</section>
</section>
<section id="the-model" class="level1">
<h1><strong>The Model</strong></h1>
<div id="ad0ce502" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> warnings</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numba <span class="im">import</span> njit</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.ensemble <span class="im">import</span> IsolationForest</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.svm <span class="im">import</span> OneClassSVM</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.neighbors <span class="im">import</span> LocalOutlierFactor</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.covariance <span class="im">import</span> EllipticEnvelope</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings(</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="st">"ignore"</span>,</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    message<span class="op">=</span><span class="st">"Determinant has increased; this should not happen"</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a><span class="at">@njit</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_windows_numba(series, window_size):</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    n_windows <span class="op">=</span> <span class="bu">len</span>(series) <span class="op">-</span> window_size <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    windows <span class="op">=</span> np.empty((n_windows, window_size), dtype<span class="op">=</span>np.float32)</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_windows):</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>        windows[i, :] <span class="op">=</span> series[i : i <span class="op">+</span> window_size]</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> windows</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a><span class="at">@njit</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> normalize_scores(scores):</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    mn <span class="op">=</span> np.<span class="bu">min</span>(scores)</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    mx <span class="op">=</span> np.<span class="bu">max</span>(scores)</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (scores <span class="op">-</span> mn) <span class="op">/</span> (mx <span class="op">-</span> mn <span class="op">+</span> <span class="fl">1e-8</span>)</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> AnomalyDetectionModel:</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, window_size<span class="op">=</span><span class="dv">30</span>, contamination<span class="op">=</span><span class="fl">0.01</span>):</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.window_size <span class="op">=</span> window_size</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.offset <span class="op">=</span> window_size <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.contamination <span class="op">=</span> contamination</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.scaler <span class="op">=</span> StandardScaler()</span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.models <span class="op">=</span> {</span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>            <span class="st">'IsolationForest'</span>: IsolationForest(contamination<span class="op">=</span>contamination, random_state<span class="op">=</span><span class="dv">42</span>),</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>            <span class="st">'OneClassSVM'</span>: OneClassSVM(kernel<span class="op">=</span><span class="st">'rbf'</span>, gamma<span class="op">=</span><span class="st">'scale'</span>, nu<span class="op">=</span>contamination),</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>            <span class="st">'EllipticEnvelope'</span>: EllipticEnvelope(contamination<span class="op">=</span>contamination,</span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>                                                 support_fraction<span class="op">=</span><span class="fl">0.75</span>,</span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>                                                 random_state<span class="op">=</span><span class="dv">42</span>),</span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.use_lof <span class="op">=</span> <span class="va">True</span></span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.lof_model <span class="op">=</span> LocalOutlierFactor(n_neighbors<span class="op">=</span><span class="dv">20</span>,</span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>                                            contamination<span class="op">=</span>contamination,</span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>                                            novelty<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.full_anomaly_mask <span class="op">=</span> <span class="va">None</span></span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> fit(<span class="va">self</span>, X: np.ndarray, y: np.ndarray <span class="op">=</span> <span class="va">None</span>):</span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.train_windows <span class="op">=</span> <span class="va">self</span>._create_windows(X)</span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.scaled_train_windows <span class="op">=</span> <span class="va">self</span>.scaler.fit_transform(<span class="va">self</span>.train_windows)</span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> model <span class="kw">in</span> <span class="va">self</span>.models.values():</span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a>            model.fit(<span class="va">self</span>.scaled_train_windows)</span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.use_lof:</span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.lof_model.fit(<span class="va">self</span>.scaled_train_windows)</span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> predict(<span class="va">self</span>, X: np.ndarray):</span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true" tabindex="-1"></a>        test_windows <span class="op">=</span> <span class="va">self</span>._create_windows(X)</span>
<span id="cb4-63"><a href="#cb4-63" aria-hidden="true" tabindex="-1"></a>        scaled <span class="op">=</span> <span class="va">self</span>.scaler.transform(test_windows)</span>
<span id="cb4-64"><a href="#cb4-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-65"><a href="#cb4-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-66"><a href="#cb4-66" aria-hidden="true" tabindex="-1"></a>        all_scores <span class="op">=</span> []</span>
<span id="cb4-67"><a href="#cb4-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> model <span class="kw">in</span> <span class="va">self</span>.models.values():</span>
<span id="cb4-68"><a href="#cb4-68" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">hasattr</span>(model, <span class="st">"decision_function"</span>):</span>
<span id="cb4-69"><a href="#cb4-69" aria-hidden="true" tabindex="-1"></a>                s <span class="op">=</span> model.decision_function(scaled)</span>
<span id="cb4-70"><a href="#cb4-70" aria-hidden="true" tabindex="-1"></a>                all_scores.append(normalize_scores(s))</span>
<span id="cb4-71"><a href="#cb4-71" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb4-72"><a href="#cb4-72" aria-hidden="true" tabindex="-1"></a>                preds <span class="op">=</span> model.predict(scaled)</span>
<span id="cb4-73"><a href="#cb4-73" aria-hidden="true" tabindex="-1"></a>                all_scores.append(np.where(preds <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>, <span class="fl">0.0</span>, <span class="fl">1.0</span>))</span>
<span id="cb4-74"><a href="#cb4-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-75"><a href="#cb4-75" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.use_lof:</span>
<span id="cb4-76"><a href="#cb4-76" aria-hidden="true" tabindex="-1"></a>            lof_s <span class="op">=</span> <span class="va">self</span>.lof_model.decision_function(scaled)</span>
<span id="cb4-77"><a href="#cb4-77" aria-hidden="true" tabindex="-1"></a>            all_scores.append(normalize_scores(lof_s))</span>
<span id="cb4-78"><a href="#cb4-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-79"><a href="#cb4-79" aria-hidden="true" tabindex="-1"></a>        avg_scores <span class="op">=</span> np.mean(np.stack(all_scores, axis<span class="op">=</span><span class="dv">0</span>), axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb4-80"><a href="#cb4-80" aria-hidden="true" tabindex="-1"></a>        thresh <span class="op">=</span> np.percentile(avg_scores, <span class="va">self</span>.contamination <span class="op">*</span> <span class="dv">100</span>)</span>
<span id="cb4-81"><a href="#cb4-81" aria-hidden="true" tabindex="-1"></a>        mask <span class="op">=</span> np.zeros(<span class="bu">len</span>(X), dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb4-82"><a href="#cb4-82" aria-hidden="true" tabindex="-1"></a>        mask[<span class="va">self</span>.offset : <span class="va">self</span>.offset <span class="op">+</span> <span class="bu">len</span>(avg_scores)] <span class="op">=</span> (avg_scores <span class="op">&lt;=</span> thresh).astype(<span class="bu">int</span>)</span>
<span id="cb4-83"><a href="#cb4-83" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.full_anomaly_mask <span class="op">=</span> mask</span>
<span id="cb4-84"><a href="#cb4-84" aria-hidden="true" tabindex="-1"></a>        idx <span class="op">=</span> np.argmin(avg_scores)</span>
<span id="cb4-85"><a href="#cb4-85" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> idx <span class="op">+</span> <span class="va">self</span>.offset</span>
<span id="cb4-86"><a href="#cb4-86" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _create_windows(<span class="va">self</span>, series: np.ndarray):</span>
<span id="cb4-87"><a href="#cb4-87" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> create_windows_numba(series, <span class="va">self</span>.window_size)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="explanation" class="level2">
<h2 class="anchored" data-anchor-id="explanation">Explanation</h2>
<p>This pipeline works on the idea that:</p>
<pre><code>    1) it builds upon sliding windows
    2) gathers normalised anomaly scores from each sub-model and uses them
    3) averages the anomaly scores
    4) computes a binary mask by thresholding at the 1st percentile so that it can compare outputs
    5) stores self.full_anomaly_mask (same length as the placeholder value)
    6) returns the single index of the lowest‐score window center which closes the loop on the sliding window idea</code></pre>
</section>
<section id="student-todo-implement-your-anomaly-detector" class="level2">
<h2 class="anchored" data-anchor-id="student-todo-implement-your-anomaly-detector"><strong>STUDENT TODO — Implement your anomaly detector</strong></h2>
<p>Implement Machine Learning/ Statistical models or both. Use the test_files (test series) to train your models and list of anomaly index range for example Anomaly 1: 2001-2005 Anomaly 2: 2010-2012</p>
<p><strong>Constraints</strong></p>
<ul>
<li>Keep it efficient; we will run this over 10 datasets and additional novel datasets in class.</li>
</ul>
<p>#EDA on given model</p>
<div id="c669d832" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Normalization</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>scaler <span class="op">=</span> StandardScaler()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="412e2a01" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Reshape</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>rx <span class="op">=</span> df[<span class="st">'Value1'</span>].values.reshape(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>np_scaled <span class="op">=</span> scaler.fit_transform(rx)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.DataFrame(np_scaled)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="f493ac9c" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:206}}" data-execution_count="6">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>data.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">0</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>-1.222425</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>-0.824437</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>-0.402862</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>-0.002453</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>0.093183</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div id="59e31064" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> StandardScaler</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> detect_peaks_anomalies(x, min_height<span class="op">=</span><span class="va">None</span>, distance<span class="op">=</span><span class="dv">20</span>):</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Peak detection for spike anomalies - WITH StandardScaler"""</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> scipy.signal <span class="im">import</span> find_peaks</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Normalize using StandardScaler</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    scaler <span class="op">=</span> StandardScaler()</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    x_normalized <span class="op">=</span> scaler.fit_transform(x.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)).flatten()</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> min_height <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        min_height <span class="op">=</span> <span class="fl">3.0</span>  <span class="co"># Now in standard deviation units</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    peaks, _ <span class="op">=</span> find_peaks(x_normalized, height<span class="op">=</span>min_height, distance<span class="op">=</span>distance)</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    neg_peaks, _ <span class="op">=</span> find_peaks(<span class="op">-</span>x_normalized, height<span class="op">=</span>min_height, distance<span class="op">=</span>distance)</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">list</span>(peaks) <span class="op">+</span> <span class="bu">list</span>(neg_peaks)</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> detect_change_point_anomalies(x, window_size<span class="op">=</span><span class="dv">50</span>):</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Detect anomalies based on distribution changes - WITH StandardScaler"""</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    anomalies <span class="op">=</span> []</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Normalize using StandardScaler</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>    scaler <span class="op">=</span> StandardScaler()</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>    x_normalized <span class="op">=</span> scaler.fit_transform(x.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)).flatten()</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(window_size, <span class="bu">len</span>(x_normalized) <span class="op">-</span> window_size):</span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>        before_window <span class="op">=</span> x_normalized[i<span class="op">-</span>window_size:i]</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>        after_window <span class="op">=</span> x_normalized[i:i<span class="op">+</span>window_size]</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Statistical test on standardized data</span></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>        mean_diff <span class="op">=</span> np.<span class="bu">abs</span>(np.mean(after_window) <span class="op">-</span> np.mean(before_window))</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>        std_before <span class="op">=</span> np.std(before_window)</span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Threshold in standard deviation units</span></span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> std_before <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> mean_diff <span class="op">&gt;</span> <span class="fl">3.0</span>:  <span class="co"># 2 standard deviations</span></span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>            anomalies.append(i)</span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> anomalies</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="873c0ee7" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-execution_count="8">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Implement your anomaly detector/ detectors. You can edit this or use your own</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> student_detect_anomalies(series: np.ndarray) <span class="op">-&gt;</span> <span class="bu">list</span>:</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Input:</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="co">        series: 1D array-like of floats (test series)</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Output:</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="co">        List of (start, end) index pairs (0-based, end exclusive) for anomaly ranges.</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.asarray(series, dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(x)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> []</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Rolling mean/std z-score on a smoothed series</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Smooth to get residuals</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    w_smooth <span class="op">=</span> <span class="dv">51</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> np.ones(w_smooth) <span class="op">/</span> w_smooth</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>    smooth <span class="op">=</span> np.convolve(x, k, mode<span class="op">=</span><span class="st">'same'</span>)</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>    resid <span class="op">=</span> x <span class="op">-</span> smooth</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 2) Rolling mean/std using convolution (no extra libs)</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>    w <span class="op">=</span> <span class="dv">61</span>  <span class="co"># odd; students may tune</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>    kw <span class="op">=</span> np.ones(w) <span class="op">/</span> w</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>    mu <span class="op">=</span> np.convolve(resid, kw, mode<span class="op">=</span><span class="st">'same'</span>)</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>    mu2 <span class="op">=</span> np.convolve(resid<span class="op">*</span>resid, kw, mode<span class="op">=</span><span class="st">'same'</span>)</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>    var <span class="op">=</span> np.maximum(mu2 <span class="op">-</span> mu<span class="op">*</span>mu, <span class="fl">1e-8</span>)</span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>    sigma <span class="op">=</span> np.sqrt(var)</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> np.<span class="bu">abs</span>((resid <span class="op">-</span> mu) <span class="op">/</span> (sigma <span class="op">+</span> <span class="fl">1e-8</span>))</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'anomalies identified.'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>anomalies identified.</code></pre>
</div>
</div>
</section>
</section>
<section id="evaluation" class="level1">
<h1><strong>Evaluation</strong></h1>
<p>The higher the accuracy the better.</p>
<div id="2d04979d" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-execution_count="9">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>correct <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> train, test <span class="kw">in</span> <span class="bu">zip</span>(train_files, test_files):</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    model <span class="op">=</span> AnomalyDetectionModel()</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    model.fit(train.Value1.to_numpy().flatten(), train.Labels.to_numpy().flatten())</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    prediction_index <span class="op">=</span> model.predict(test.Value1.to_numpy().flatten())</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (test.loc[prediction_index, <span class="st">"Labels"</span>] <span class="op">==</span> <span class="dv">1</span>):</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>        correct <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Total score: </span><span class="sc">{</span>correct<span class="sc">}</span><span class="ss">%"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Total score: 10%</code></pre>
</div>
</div>
<div id="5b1a3a54" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Use other various evaluation metrics applicable to your models.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>#<strong>Limitations</strong> While the ensemble sliding-window model seems to be a good fir,it does have some downsides.</p>
<p>##<strong>Computational Cost</strong>: Because the model creates overlapping windows and runs multiple anomaly detection algorithms on each window, it can be computationally intensive—especially for long time series or when using a small window size (which results in many windows).</p>
<p>##<strong>This means it will require increased memory usage</strong></p>
<p>##<strong>It also means longer runtime compared to a single-model approach</strong></p>
<p>It may not be suitable for very large datasets or real-time applications unless optimized or run on powerful hardware and there are some constructive bial issues that still need to be tested.</p>
<p><strong><em>For faster experiments, we could use a larger window size, downsampling the data, or disabling one or more models in the ensemble, but for this we need testing</em></strong></p>
</section>
<section id="visualisation-of-the-anomalies" class="level1">
<h1><strong>Visualisation of the anomalies</strong></h1>
<p>Reuse this code to visualize the anomalies.</p>
<div id="98dfefa8" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:1000}}" data-execution_count="11">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> visualize_anomaly_detection(test_df, model, file_idx<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Visualizes:</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="co">    - Signal (black)</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="co">    - Ground truth anomalies (red)</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="co">    - Predicted anomalies (green)</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="co">    - Most anomalous index (blue dot)</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    series <span class="op">=</span> test_df[<span class="st">'Value1'</span>].to_numpy()</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    true_mask <span class="op">=</span> test_df[<span class="st">'Labels'</span>].to_numpy().astype(<span class="bu">bool</span>)</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    pred_mask <span class="op">=</span> model.full_anomaly_mask.astype(<span class="bu">bool</span>)</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    most_anomalous <span class="op">=</span> np.argmin(pred_mask) <span class="cf">if</span> pred_mask.<span class="bu">any</span>() <span class="cf">else</span> <span class="va">None</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    pred_index <span class="op">=</span> model.predict(series)  <span class="co"># triggers .full_anomaly_mask</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">14</span>, <span class="dv">4</span>))</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>    plt.plot(series, color<span class="op">=</span><span class="st">'black'</span>, lw<span class="op">=</span><span class="dv">1</span>, label<span class="op">=</span><span class="st">'Signal'</span>)</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> pred_mask.<span class="bu">any</span>():</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>        plt.fill_between(np.arange(<span class="bu">len</span>(series)), series,</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>                         where<span class="op">=</span>pred_mask, color<span class="op">=</span><span class="st">'green'</span>, alpha<span class="op">=</span><span class="fl">0.3</span>,</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>                         label<span class="op">=</span><span class="st">'Predicted Anomaly'</span>)</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> true_mask.<span class="bu">any</span>():</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>        plt.fill_between(np.arange(<span class="bu">len</span>(series)), series,</span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>                         where<span class="op">=</span>true_mask, color<span class="op">=</span><span class="st">'red'</span>, alpha<span class="op">=</span><span class="fl">0.3</span>,</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>                         label<span class="op">=</span><span class="st">'True Anomaly'</span>)</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="dv">0</span> <span class="op">&lt;=</span> pred_index <span class="op">&lt;</span> <span class="bu">len</span>(series):</span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>        plt.scatter(pred_index, series[pred_index], color<span class="op">=</span><span class="st">'blue'</span>, s<span class="op">=</span><span class="dv">50</span>, label<span class="op">=</span><span class="st">'Most Anomalous Point'</span>)</span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>    title <span class="op">=</span> <span class="ss">f"File </span><span class="sc">{</span>file_idx<span class="sc">}</span><span class="ss">"</span> <span class="cf">if</span> file_idx <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="cf">else</span> <span class="st">"Anomaly Detection"</span></span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>    plt.title(title)</span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">"Time Step"</span>)</span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">"Value"</span>)</span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>    plt.legend(loc<span class="op">=</span><span class="st">"upper right"</span>)</span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a><span class="co"># -- Loop over all files and visualize each --</span></span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> idx, (train, test) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(train_files, test_files), <span class="dv">1</span>):</span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true" tabindex="-1"></a>    model <span class="op">=</span> AnomalyDetectionModel(window_size<span class="op">=</span><span class="dv">30</span>, contamination<span class="op">=</span><span class="fl">0.01</span>)</span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true" tabindex="-1"></a>    model.fit(train[<span class="st">'Value1'</span>].to_numpy(), train[<span class="st">'Labels'</span>].to_numpy())</span>
<span id="cb15-44"><a href="#cb15-44" aria-hidden="true" tabindex="-1"></a>    model.predict(test[<span class="st">'Value1'</span>].to_numpy())  <span class="co"># sets .full_anomaly_mask</span></span>
<span id="cb15-45"><a href="#cb15-45" aria-hidden="true" tabindex="-1"></a>    visualize_anomaly_detection(test, model, file_idx<span class="op">=</span>idx)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-12-output-1.png" width="1334" height="374" class="figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-12-output-2.png" width="1334" height="374" class="figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-12-output-3.png" width="1334" height="374" class="figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-12-output-4.png" width="1334" height="374" class="figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-12-output-5.png" width="1334" height="374" class="figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-12-output-6.png" width="1334" height="374" class="figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-12-output-7.png" width="1334" height="374" class="figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-12-output-8.png" width="1334" height="374" class="figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-12-output-9.png" width="1334" height="374" class="figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-12-output-10.png" width="1334" height="374" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>#EDA</p>
<div id="4f041afc" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:206}}" data-execution_count="12">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="12">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Value1</th>
<th data-quarto-table-cell-role="th">Labels</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>20.801402</td>
<td>0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>26.800208</td>
<td>0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>33.154527</td>
<td>0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>39.189824</td>
<td>0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>40.631321</td>
<td>0</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div id="60964358" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-execution_count="13">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df.shape)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Data Types"</span>, df.dtypes)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Descriptive stats:"</span>, df[<span class="st">'Value1'</span>].describe())</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>missing_vals <span class="op">=</span> df[<span class="st">'Value1'</span>].isna().<span class="bu">sum</span>()</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Missing Total values: </span><span class="sc">{</span>missing_vals<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>(10000, 2)
Data Types Value1    float64
Labels      int64
dtype: object
Descriptive stats: count    10000.000000
mean        39.226792
std         15.073575
min          0.000000
25%         32.807308
50%         39.452857
75%         45.885332
max        100.000000
Name: Value1, dtype: float64

Missing Total values: 0</code></pre>
</div>
</div>
<div id="609c5c65" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:300}}" data-execution_count="14">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>df.describe()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="14">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Value1</th>
<th data-quarto-table-cell-role="th">Labels</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">count</td>
<td>10000.000000</td>
<td>10000.000000</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">mean</td>
<td>39.226792</td>
<td>0.089200</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">std</td>
<td>15.073575</td>
<td>0.285046</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">min</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">25%</td>
<td>32.807308</td>
<td>0.000000</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">50%</td>
<td>39.452857</td>
<td>0.000000</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">75%</td>
<td>45.885332</td>
<td>0.000000</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">max</td>
<td>100.000000</td>
<td>1.000000</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div id="b9a90ccf" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:659}}" data-execution_count="15">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Show histograms - all variables except for the identifier</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>df.hist(bins <span class="op">=</span> <span class="dv">20</span>, figsize <span class="op">=</span>(<span class="dv">20</span>, <span class="dv">10</span>))</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-16-output-1.png" width="1550" height="801" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Comprehensive EDA with statistical analysis and visualizations</p>
<p>Proper preprocessing using StandardScaler</p>
<p>Feature engineering with rolling window statistics</p>
<p>Isolation Forest model with configurable parameters</p>
<p>Range-based detection that groups consecutive anomalies</p>
<p>Comprehensive evaluation with precision, recall, and F1-score</p>
<p>Visualization to compare true vs predicted anomalies</p>
<div id="359be2f0" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;,&quot;height&quot;:1000}}" data-execution_count="16">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Enhanced Isolation Forest Anomaly Detector with 10-anomaly target</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> IsolationForestAnomalyDetector:</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, target_anomalies<span class="op">=</span><span class="dv">10</span>, contamination_range<span class="op">=</span>(<span class="fl">0.01</span>, <span class="fl">0.2</span>), random_state<span class="op">=</span><span class="dv">42</span>):</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.target_anomalies <span class="op">=</span> target_anomalies</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.contamination_range <span class="op">=</span> contamination_range</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.random_state <span class="op">=</span> random_state</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.scaler <span class="op">=</span> StandardScaler()</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.model <span class="op">=</span> <span class="va">None</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.anomaly_windows <span class="op">=</span> []</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.optimal_contamination <span class="op">=</span> <span class="va">None</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> create_features(<span class="va">self</span>, series, window_size<span class="op">=</span><span class="dv">50</span>):</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Create rolling window features for better anomaly detection"""</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>        series <span class="op">=</span> np.array(series).reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Basic statistical features</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>        features <span class="op">=</span> []</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Original value</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>        features.append(series)</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Rolling statistics</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> window <span class="kw">in</span> [<span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">50</span>]:</span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">len</span>(series) <span class="op">&gt;=</span> window:</span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Rolling mean</span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>                roll_mean <span class="op">=</span> pd.Series(series.flatten()).rolling(window<span class="op">=</span>window, center<span class="op">=</span><span class="va">True</span>).mean().values.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a>                features.append(roll_mean)</span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Rolling standard deviation</span></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>                roll_std <span class="op">=</span> pd.Series(series.flatten()).rolling(window<span class="op">=</span>window, center<span class="op">=</span><span class="va">True</span>).std().values.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a>                features.append(roll_std)</span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Difference from rolling mean</span></span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>                diff_from_mean <span class="op">=</span> series <span class="op">-</span> roll_mean</span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a>                features.append(diff_from_mean)</span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add more features for better detection</span></span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Z-score</span></span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a>        z_score <span class="op">=</span> (series <span class="op">-</span> np.mean(series)) <span class="op">/</span> np.std(series)</span>
<span id="cb21-40"><a href="#cb21-40" aria-hidden="true" tabindex="-1"></a>        features.append(z_score)</span>
<span id="cb21-41"><a href="#cb21-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-42"><a href="#cb21-42" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Combine all features</span></span>
<span id="cb21-43"><a href="#cb21-43" aria-hidden="true" tabindex="-1"></a>        feature_matrix <span class="op">=</span> np.hstack([f <span class="cf">for</span> f <span class="kw">in</span> features <span class="cf">if</span> f <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="kw">and</span> <span class="kw">not</span> np.<span class="bu">any</span>(np.isnan(f))])</span>
<span id="cb21-44"><a href="#cb21-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-45"><a href="#cb21-45" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Handle NaN values that might occur from rolling operations</span></span>
<span id="cb21-46"><a href="#cb21-46" aria-hidden="true" tabindex="-1"></a>        feature_matrix <span class="op">=</span> np.nan_to_num(feature_matrix)</span>
<span id="cb21-47"><a href="#cb21-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-48"><a href="#cb21-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> feature_matrix</span>
<span id="cb21-49"><a href="#cb21-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-50"><a href="#cb21-50" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> find_anomaly_ranges(<span class="va">self</span>, predictions, min_consecutive<span class="op">=</span><span class="dv">3</span>):</span>
<span id="cb21-51"><a href="#cb21-51" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Convert point anomalies to ranges"""</span></span>
<span id="cb21-52"><a href="#cb21-52" aria-hidden="true" tabindex="-1"></a>        anomaly_indices <span class="op">=</span> np.where(predictions <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>)[<span class="dv">0</span>]</span>
<span id="cb21-53"><a href="#cb21-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-54"><a href="#cb21-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(anomaly_indices) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb21-55"><a href="#cb21-55" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> []</span>
<span id="cb21-56"><a href="#cb21-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-57"><a href="#cb21-57" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Group consecutive anomalies</span></span>
<span id="cb21-58"><a href="#cb21-58" aria-hidden="true" tabindex="-1"></a>        ranges <span class="op">=</span> []</span>
<span id="cb21-59"><a href="#cb21-59" aria-hidden="true" tabindex="-1"></a>        start <span class="op">=</span> anomaly_indices[<span class="dv">0</span>]</span>
<span id="cb21-60"><a href="#cb21-60" aria-hidden="true" tabindex="-1"></a>        end <span class="op">=</span> anomaly_indices[<span class="dv">0</span>]</span>
<span id="cb21-61"><a href="#cb21-61" aria-hidden="true" tabindex="-1"></a>        count <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb21-62"><a href="#cb21-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-63"><a href="#cb21-63" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(anomaly_indices)):</span>
<span id="cb21-64"><a href="#cb21-64" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> anomaly_indices[i] <span class="op">==</span> anomaly_indices[i<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span>:</span>
<span id="cb21-65"><a href="#cb21-65" aria-hidden="true" tabindex="-1"></a>                end <span class="op">=</span> anomaly_indices[i]</span>
<span id="cb21-66"><a href="#cb21-66" aria-hidden="true" tabindex="-1"></a>                count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb21-67"><a href="#cb21-67" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb21-68"><a href="#cb21-68" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Only keep ranges with minimum consecutive anomalies</span></span>
<span id="cb21-69"><a href="#cb21-69" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> count <span class="op">&gt;=</span> min_consecutive:</span>
<span id="cb21-70"><a href="#cb21-70" aria-hidden="true" tabindex="-1"></a>                    ranges.append((start, end))</span>
<span id="cb21-71"><a href="#cb21-71" aria-hidden="true" tabindex="-1"></a>                start <span class="op">=</span> anomaly_indices[i]</span>
<span id="cb21-72"><a href="#cb21-72" aria-hidden="true" tabindex="-1"></a>                end <span class="op">=</span> anomaly_indices[i]</span>
<span id="cb21-73"><a href="#cb21-73" aria-hidden="true" tabindex="-1"></a>                count <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb21-74"><a href="#cb21-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-75"><a href="#cb21-75" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add the last range</span></span>
<span id="cb21-76"><a href="#cb21-76" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> count <span class="op">&gt;=</span> min_consecutive:</span>
<span id="cb21-77"><a href="#cb21-77" aria-hidden="true" tabindex="-1"></a>            ranges.append((start, end))</span>
<span id="cb21-78"><a href="#cb21-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-79"><a href="#cb21-79" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ranges</span>
<span id="cb21-80"><a href="#cb21-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-81"><a href="#cb21-81" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> optimize_contamination(<span class="va">self</span>, X):</span>
<span id="cb21-82"><a href="#cb21-82" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Find optimal contamination parameter to get close to target anomalies"""</span></span>
<span id="cb21-83"><a href="#cb21-83" aria-hidden="true" tabindex="-1"></a>        best_contamination <span class="op">=</span> <span class="va">self</span>.contamination_range[<span class="dv">0</span>]</span>
<span id="cb21-84"><a href="#cb21-84" aria-hidden="true" tabindex="-1"></a>        best_diff <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb21-85"><a href="#cb21-85" aria-hidden="true" tabindex="-1"></a>        best_predictions <span class="op">=</span> <span class="va">None</span></span>
<span id="cb21-86"><a href="#cb21-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-87"><a href="#cb21-87" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Test multiple contamination values</span></span>
<span id="cb21-88"><a href="#cb21-88" aria-hidden="true" tabindex="-1"></a>        contamination_values <span class="op">=</span> np.linspace(<span class="va">self</span>.contamination_range[<span class="dv">0</span>], <span class="va">self</span>.contamination_range[<span class="dv">1</span>], <span class="dv">20</span>)</span>
<span id="cb21-89"><a href="#cb21-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-90"><a href="#cb21-90" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> contamination <span class="kw">in</span> contamination_values:</span>
<span id="cb21-91"><a href="#cb21-91" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Create features</span></span>
<span id="cb21-92"><a href="#cb21-92" aria-hidden="true" tabindex="-1"></a>            X_features <span class="op">=</span> <span class="va">self</span>.create_features(X)</span>
<span id="cb21-93"><a href="#cb21-93" aria-hidden="true" tabindex="-1"></a>            X_scaled <span class="op">=</span> <span class="va">self</span>.scaler.fit_transform(X_features)</span>
<span id="cb21-94"><a href="#cb21-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-95"><a href="#cb21-95" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Train Isolation Forest</span></span>
<span id="cb21-96"><a href="#cb21-96" aria-hidden="true" tabindex="-1"></a>            model <span class="op">=</span> IsolationForest(</span>
<span id="cb21-97"><a href="#cb21-97" aria-hidden="true" tabindex="-1"></a>                contamination<span class="op">=</span>contamination,</span>
<span id="cb21-98"><a href="#cb21-98" aria-hidden="true" tabindex="-1"></a>                random_state<span class="op">=</span><span class="va">self</span>.random_state,</span>
<span id="cb21-99"><a href="#cb21-99" aria-hidden="true" tabindex="-1"></a>                n_estimators<span class="op">=</span><span class="dv">100</span></span>
<span id="cb21-100"><a href="#cb21-100" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb21-101"><a href="#cb21-101" aria-hidden="true" tabindex="-1"></a>            model.fit(X_scaled)</span>
<span id="cb21-102"><a href="#cb21-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-103"><a href="#cb21-103" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Predict anomalies</span></span>
<span id="cb21-104"><a href="#cb21-104" aria-hidden="true" tabindex="-1"></a>            predictions <span class="op">=</span> model.predict(X_scaled)</span>
<span id="cb21-105"><a href="#cb21-105" aria-hidden="true" tabindex="-1"></a>            n_anomalies <span class="op">=</span> np.<span class="bu">sum</span>(predictions <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb21-106"><a href="#cb21-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-107"><a href="#cb21-107" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Calculate how close we are to target</span></span>
<span id="cb21-108"><a href="#cb21-108" aria-hidden="true" tabindex="-1"></a>            diff <span class="op">=</span> <span class="bu">abs</span>(n_anomalies <span class="op">-</span> <span class="va">self</span>.target_anomalies)</span>
<span id="cb21-109"><a href="#cb21-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-110"><a href="#cb21-110" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> diff <span class="op">&lt;</span> best_diff:</span>
<span id="cb21-111"><a href="#cb21-111" aria-hidden="true" tabindex="-1"></a>                best_diff <span class="op">=</span> diff</span>
<span id="cb21-112"><a href="#cb21-112" aria-hidden="true" tabindex="-1"></a>                best_contamination <span class="op">=</span> contamination</span>
<span id="cb21-113"><a href="#cb21-113" aria-hidden="true" tabindex="-1"></a>                best_predictions <span class="op">=</span> predictions</span>
<span id="cb21-114"><a href="#cb21-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-115"><a href="#cb21-115" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.optimal_contamination <span class="op">=</span> best_contamination</span>
<span id="cb21-116"><a href="#cb21-116" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> best_predictions, best_contamination</span>
<span id="cb21-117"><a href="#cb21-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-118"><a href="#cb21-118" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> fit(<span class="va">self</span>, X):</span>
<span id="cb21-119"><a href="#cb21-119" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Fit the model on training data with optimized contamination"""</span></span>
<span id="cb21-120"><a href="#cb21-120" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Optimize contamination parameter</span></span>
<span id="cb21-121"><a href="#cb21-121" aria-hidden="true" tabindex="-1"></a>        predictions, optimal_contamination <span class="op">=</span> <span class="va">self</span>.optimize_contamination(X)</span>
<span id="cb21-122"><a href="#cb21-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-123"><a href="#cb21-123" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Create features</span></span>
<span id="cb21-124"><a href="#cb21-124" aria-hidden="true" tabindex="-1"></a>        X_features <span class="op">=</span> <span class="va">self</span>.create_features(X)</span>
<span id="cb21-125"><a href="#cb21-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-126"><a href="#cb21-126" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Scale the features</span></span>
<span id="cb21-127"><a href="#cb21-127" aria-hidden="true" tabindex="-1"></a>        X_scaled <span class="op">=</span> <span class="va">self</span>.scaler.fit_transform(X_features)</span>
<span id="cb21-128"><a href="#cb21-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-129"><a href="#cb21-129" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Train final Isolation Forest with optimal contamination</span></span>
<span id="cb21-130"><a href="#cb21-130" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.model <span class="op">=</span> IsolationForest(</span>
<span id="cb21-131"><a href="#cb21-131" aria-hidden="true" tabindex="-1"></a>            contamination<span class="op">=</span>optimal_contamination,</span>
<span id="cb21-132"><a href="#cb21-132" aria-hidden="true" tabindex="-1"></a>            random_state<span class="op">=</span><span class="va">self</span>.random_state,</span>
<span id="cb21-133"><a href="#cb21-133" aria-hidden="true" tabindex="-1"></a>            n_estimators<span class="op">=</span><span class="dv">100</span></span>
<span id="cb21-134"><a href="#cb21-134" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb21-135"><a href="#cb21-135" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.model.fit(X_scaled)</span>
<span id="cb21-136"><a href="#cb21-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-137"><a href="#cb21-137" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Store anomaly windows</span></span>
<span id="cb21-138"><a href="#cb21-138" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.anomaly_windows <span class="op">=</span> <span class="va">self</span>.find_anomaly_ranges(predictions)</span>
<span id="cb21-139"><a href="#cb21-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-140"><a href="#cb21-140" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Optimal contamination: </span><span class="sc">{</span>optimal_contamination<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb21-141"><a href="#cb21-141" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Number of anomaly points detected: </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">sum</span>(predictions <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-142"><a href="#cb21-142" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Number of anomaly ranges: </span><span class="sc">{</span><span class="bu">len</span>(<span class="va">self</span>.anomaly_windows)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-143"><a href="#cb21-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-144"><a href="#cb21-144" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> predict(<span class="va">self</span>, X):</span>
<span id="cb21-145"><a href="#cb21-145" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Predict anomalies on test data"""</span></span>
<span id="cb21-146"><a href="#cb21-146" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Create features</span></span>
<span id="cb21-147"><a href="#cb21-147" aria-hidden="true" tabindex="-1"></a>        X_features <span class="op">=</span> <span class="va">self</span>.create_features(X)</span>
<span id="cb21-148"><a href="#cb21-148" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-149"><a href="#cb21-149" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Scale the features</span></span>
<span id="cb21-150"><a href="#cb21-150" aria-hidden="true" tabindex="-1"></a>        X_scaled <span class="op">=</span> <span class="va">self</span>.scaler.transform(X_features)</span>
<span id="cb21-151"><a href="#cb21-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-152"><a href="#cb21-152" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Predict anomalies</span></span>
<span id="cb21-153"><a href="#cb21-153" aria-hidden="true" tabindex="-1"></a>        predictions <span class="op">=</span> <span class="va">self</span>.model.predict(X_scaled)</span>
<span id="cb21-154"><a href="#cb21-154" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-155"><a href="#cb21-155" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Convert to binary (1 = normal, -1 = anomaly)</span></span>
<span id="cb21-156"><a href="#cb21-156" aria-hidden="true" tabindex="-1"></a>        binary_predictions <span class="op">=</span> np.where(predictions <span class="op">==</span> <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb21-157"><a href="#cb21-157" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-158"><a href="#cb21-158" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Find anomaly ranges</span></span>
<span id="cb21-159"><a href="#cb21-159" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.anomaly_windows <span class="op">=</span> <span class="va">self</span>.find_anomaly_ranges(predictions)</span>
<span id="cb21-160"><a href="#cb21-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-161"><a href="#cb21-161" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> binary_predictions</span>
<span id="cb21-162"><a href="#cb21-162" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-163"><a href="#cb21-163" aria-hidden="true" tabindex="-1"></a><span class="co"># Enhanced student anomaly detector with 10-anomaly target</span></span>
<span id="cb21-164"><a href="#cb21-164" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> student_detect_anomalies(series: np.ndarray) <span class="op">-&gt;</span> <span class="bu">list</span>:</span>
<span id="cb21-165"><a href="#cb21-165" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb21-166"><a href="#cb21-166" aria-hidden="true" tabindex="-1"></a><span class="co">    Input:</span></span>
<span id="cb21-167"><a href="#cb21-167" aria-hidden="true" tabindex="-1"></a><span class="co">    series: 1D array-like of floats (test series)</span></span>
<span id="cb21-168"><a href="#cb21-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-169"><a href="#cb21-169" aria-hidden="true" tabindex="-1"></a><span class="co">    Output:</span></span>
<span id="cb21-170"><a href="#cb21-170" aria-hidden="true" tabindex="-1"></a><span class="co">    List of (start, end) index pairs (0-based, end inclusive) for anomaly ranges.</span></span>
<span id="cb21-171"><a href="#cb21-171" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb21-172"><a href="#cb21-172" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.asarray(series, dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb21-173"><a href="#cb21-173" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(x)</span>
<span id="cb21-174"><a href="#cb21-174" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-175"><a href="#cb21-175" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb21-176"><a href="#cb21-176" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> []</span>
<span id="cb21-177"><a href="#cb21-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-178"><a href="#cb21-178" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize and fit the Isolation Forest detector with 10-anomaly target</span></span>
<span id="cb21-179"><a href="#cb21-179" aria-hidden="true" tabindex="-1"></a>    detector <span class="op">=</span> IsolationForestAnomalyDetector(</span>
<span id="cb21-180"><a href="#cb21-180" aria-hidden="true" tabindex="-1"></a>        target_anomalies<span class="op">=</span><span class="dv">10</span>,</span>
<span id="cb21-181"><a href="#cb21-181" aria-hidden="true" tabindex="-1"></a>        contamination_range<span class="op">=</span>(<span class="fl">0.005</span>, <span class="fl">0.3</span>),  <span class="co"># Wider range to find optimal value</span></span>
<span id="cb21-182"><a href="#cb21-182" aria-hidden="true" tabindex="-1"></a>        random_state<span class="op">=</span><span class="dv">42</span></span>
<span id="cb21-183"><a href="#cb21-183" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb21-184"><a href="#cb21-184" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-185"><a href="#cb21-185" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fit on the test series</span></span>
<span id="cb21-186"><a href="#cb21-186" aria-hidden="true" tabindex="-1"></a>    detector.fit(x)</span>
<span id="cb21-187"><a href="#cb21-187" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-188"><a href="#cb21-188" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Return the detected anomaly ranges</span></span>
<span id="cb21-189"><a href="#cb21-189" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> detector.anomaly_windows</span>
<span id="cb21-190"><a href="#cb21-190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-191"><a href="#cb21-191" aria-hidden="true" tabindex="-1"></a><span class="co"># Enhanced evaluation function with detailed accuracy metrics</span></span>
<span id="cb21-192"><a href="#cb21-192" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evaluate_anomaly_detection_enhanced(true_ranges, predicted_ranges, tolerance<span class="op">=</span><span class="dv">5</span>, target_anomalies<span class="op">=</span><span class="dv">10</span>):</span>
<span id="cb21-193"><a href="#cb21-193" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb21-194"><a href="#cb21-194" aria-hidden="true" tabindex="-1"></a><span class="co">    Enhanced evaluation with accuracy metrics and target-based scoring</span></span>
<span id="cb21-195"><a href="#cb21-195" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb21-196"><a href="#cb21-196" aria-hidden="true" tabindex="-1"></a>    true_positives <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb21-197"><a href="#cb21-197" aria-hidden="true" tabindex="-1"></a>    false_positives <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb21-198"><a href="#cb21-198" aria-hidden="true" tabindex="-1"></a>    false_negatives <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb21-199"><a href="#cb21-199" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-200"><a href="#cb21-200" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert true ranges from labels</span></span>
<span id="cb21-201"><a href="#cb21-201" aria-hidden="true" tabindex="-1"></a>    true_anomaly_segments <span class="op">=</span> []</span>
<span id="cb21-202"><a href="#cb21-202" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> true_range <span class="kw">in</span> true_ranges:</span>
<span id="cb21-203"><a href="#cb21-203" aria-hidden="true" tabindex="-1"></a>        true_anomaly_segments.append((true_range[<span class="dv">0</span>], true_range[<span class="dv">1</span>]))</span>
<span id="cb21-204"><a href="#cb21-204" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-205"><a href="#cb21-205" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check each predicted range against true ranges</span></span>
<span id="cb21-206"><a href="#cb21-206" aria-hidden="true" tabindex="-1"></a>    matched_true <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb21-207"><a href="#cb21-207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-208"><a href="#cb21-208" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> pred_start, pred_end <span class="kw">in</span> predicted_ranges:</span>
<span id="cb21-209"><a href="#cb21-209" aria-hidden="true" tabindex="-1"></a>        matched <span class="op">=</span> <span class="va">False</span></span>
<span id="cb21-210"><a href="#cb21-210" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, (true_start, true_end) <span class="kw">in</span> <span class="bu">enumerate</span>(true_anomaly_segments):</span>
<span id="cb21-211"><a href="#cb21-211" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Check if predicted range overlaps with true range within tolerance</span></span>
<span id="cb21-212"><a href="#cb21-212" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (pred_start <span class="op">&lt;=</span> true_end <span class="op">+</span> tolerance <span class="kw">and</span> pred_end <span class="op">&gt;=</span> true_start <span class="op">-</span> tolerance):</span>
<span id="cb21-213"><a href="#cb21-213" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> i <span class="kw">not</span> <span class="kw">in</span> matched_true:</span>
<span id="cb21-214"><a href="#cb21-214" aria-hidden="true" tabindex="-1"></a>                    true_positives <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb21-215"><a href="#cb21-215" aria-hidden="true" tabindex="-1"></a>                    matched_true.add(i)</span>
<span id="cb21-216"><a href="#cb21-216" aria-hidden="true" tabindex="-1"></a>                    matched <span class="op">=</span> <span class="va">True</span></span>
<span id="cb21-217"><a href="#cb21-217" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">break</span></span>
<span id="cb21-218"><a href="#cb21-218" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-219"><a href="#cb21-219" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> matched:</span>
<span id="cb21-220"><a href="#cb21-220" aria-hidden="true" tabindex="-1"></a>            false_positives <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb21-221"><a href="#cb21-221" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-222"><a href="#cb21-222" aria-hidden="true" tabindex="-1"></a>    false_negatives <span class="op">=</span> <span class="bu">len</span>(true_anomaly_segments) <span class="op">-</span> <span class="bu">len</span>(matched_true)</span>
<span id="cb21-223"><a href="#cb21-223" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-224"><a href="#cb21-224" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate standard metrics</span></span>
<span id="cb21-225"><a href="#cb21-225" aria-hidden="true" tabindex="-1"></a>    precision <span class="op">=</span> true_positives <span class="op">/</span> (true_positives <span class="op">+</span> false_positives) <span class="cf">if</span> (true_positives <span class="op">+</span> false_positives) <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb21-226"><a href="#cb21-226" aria-hidden="true" tabindex="-1"></a>    recall <span class="op">=</span> true_positives <span class="op">/</span> <span class="bu">len</span>(true_anomaly_segments) <span class="cf">if</span> <span class="bu">len</span>(true_anomaly_segments) <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb21-227"><a href="#cb21-227" aria-hidden="true" tabindex="-1"></a>    f1 <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> (precision <span class="op">*</span> recall) <span class="op">/</span> (precision <span class="op">+</span> recall) <span class="cf">if</span> (precision <span class="op">+</span> recall) <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb21-228"><a href="#cb21-228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-229"><a href="#cb21-229" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate accuracy metrics</span></span>
<span id="cb21-230"><a href="#cb21-230" aria-hidden="true" tabindex="-1"></a>    total_predictions <span class="op">=</span> <span class="bu">len</span>(predicted_ranges)</span>
<span id="cb21-231"><a href="#cb21-231" aria-hidden="true" tabindex="-1"></a>    target_accuracy <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> <span class="bu">min</span>(<span class="bu">abs</span>(total_predictions <span class="op">-</span> target_anomalies) <span class="op">/</span> target_anomalies, <span class="fl">1.0</span>)</span>
<span id="cb21-232"><a href="#cb21-232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-233"><a href="#cb21-233" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Combined score (weighted average of F1 and target accuracy)</span></span>
<span id="cb21-234"><a href="#cb21-234" aria-hidden="true" tabindex="-1"></a>    combined_score <span class="op">=</span> <span class="fl">0.7</span> <span class="op">*</span> f1 <span class="op">+</span> <span class="fl">0.3</span> <span class="op">*</span> target_accuracy</span>
<span id="cb21-235"><a href="#cb21-235" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-236"><a href="#cb21-236" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Detection success (1 if at least one true positive, 0 otherwise)</span></span>
<span id="cb21-237"><a href="#cb21-237" aria-hidden="true" tabindex="-1"></a>    detection_success <span class="op">=</span> <span class="dv">1</span> <span class="cf">if</span> true_positives <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb21-238"><a href="#cb21-238" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-239"><a href="#cb21-239" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {</span>
<span id="cb21-240"><a href="#cb21-240" aria-hidden="true" tabindex="-1"></a>        <span class="st">'true_positives'</span>: true_positives,</span>
<span id="cb21-241"><a href="#cb21-241" aria-hidden="true" tabindex="-1"></a>        <span class="st">'false_positives'</span>: false_positives,</span>
<span id="cb21-242"><a href="#cb21-242" aria-hidden="true" tabindex="-1"></a>        <span class="st">'false_negatives'</span>: false_negatives,</span>
<span id="cb21-243"><a href="#cb21-243" aria-hidden="true" tabindex="-1"></a>        <span class="st">'precision'</span>: precision,</span>
<span id="cb21-244"><a href="#cb21-244" aria-hidden="true" tabindex="-1"></a>        <span class="st">'recall'</span>: recall,</span>
<span id="cb21-245"><a href="#cb21-245" aria-hidden="true" tabindex="-1"></a>        <span class="st">'f1_score'</span>: f1,</span>
<span id="cb21-246"><a href="#cb21-246" aria-hidden="true" tabindex="-1"></a>        <span class="st">'target_accuracy'</span>: target_accuracy,</span>
<span id="cb21-247"><a href="#cb21-247" aria-hidden="true" tabindex="-1"></a>        <span class="st">'combined_score'</span>: combined_score,</span>
<span id="cb21-248"><a href="#cb21-248" aria-hidden="true" tabindex="-1"></a>        <span class="st">'detection_success'</span>: detection_success,</span>
<span id="cb21-249"><a href="#cb21-249" aria-hidden="true" tabindex="-1"></a>        <span class="st">'total_predicted_ranges'</span>: total_predictions,</span>
<span id="cb21-250"><a href="#cb21-250" aria-hidden="true" tabindex="-1"></a>        <span class="st">'total_true_ranges'</span>: <span class="bu">len</span>(true_anomaly_segments)</span>
<span id="cb21-251"><a href="#cb21-251" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb21-252"><a href="#cb21-252" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-253"><a href="#cb21-253" aria-hidden="true" tabindex="-1"></a><span class="co"># Enhanced visualization with accuracy information</span></span>
<span id="cb21-254"><a href="#cb21-254" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> visualize_anomaly_detection_with_accuracy(test_df, predicted_ranges, metrics, file_idx<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb21-255"><a href="#cb21-255" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Visualize the anomaly detection results with accuracy information"""</span></span>
<span id="cb21-256"><a href="#cb21-256" aria-hidden="true" tabindex="-1"></a>    series <span class="op">=</span> test_df[<span class="st">'Value'</span>].values <span class="cf">if</span> <span class="st">'Value'</span> <span class="kw">in</span> test_df.columns <span class="cf">else</span> test_df.iloc[:, <span class="dv">0</span>].values</span>
<span id="cb21-257"><a href="#cb21-257" aria-hidden="true" tabindex="-1"></a>    true_labels <span class="op">=</span> test_df[<span class="st">'Labels'</span>].values <span class="cf">if</span> <span class="st">'Labels'</span> <span class="kw">in</span> test_df.columns <span class="cf">else</span> test_df.iloc[:, <span class="dv">1</span>].values</span>
<span id="cb21-258"><a href="#cb21-258" aria-hidden="true" tabindex="-1"></a>    true_mask <span class="op">=</span> true_labels.astype(<span class="bu">bool</span>)</span>
<span id="cb21-259"><a href="#cb21-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-260"><a href="#cb21-260" aria-hidden="true" tabindex="-1"></a>    plt.figure(figsize<span class="op">=</span>(<span class="dv">16</span>, <span class="dv">8</span>))</span>
<span id="cb21-261"><a href="#cb21-261" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-262"><a href="#cb21-262" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot the signal</span></span>
<span id="cb21-263"><a href="#cb21-263" aria-hidden="true" tabindex="-1"></a>    plt.plot(series, color<span class="op">=</span><span class="st">'black'</span>, linewidth<span class="op">=</span><span class="dv">1</span>, label<span class="op">=</span><span class="st">'Signal'</span>)</span>
<span id="cb21-264"><a href="#cb21-264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-265"><a href="#cb21-265" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot true anomalies</span></span>
<span id="cb21-266"><a href="#cb21-266" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> true_mask.<span class="bu">any</span>():</span>
<span id="cb21-267"><a href="#cb21-267" aria-hidden="true" tabindex="-1"></a>        plt.fill_between(np.arange(<span class="bu">len</span>(series)), np.<span class="bu">min</span>(series), np.<span class="bu">max</span>(series),</span>
<span id="cb21-268"><a href="#cb21-268" aria-hidden="true" tabindex="-1"></a>                        where<span class="op">=</span>true_mask, color<span class="op">=</span><span class="st">'red'</span>, alpha<span class="op">=</span><span class="fl">0.3</span>, label<span class="op">=</span><span class="st">'True Anomalies'</span>)</span>
<span id="cb21-269"><a href="#cb21-269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-270"><a href="#cb21-270" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot predicted anomalies</span></span>
<span id="cb21-271"><a href="#cb21-271" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> start, end <span class="kw">in</span> predicted_ranges:</span>
<span id="cb21-272"><a href="#cb21-272" aria-hidden="true" tabindex="-1"></a>        plt.axvspan(start, end, alpha<span class="op">=</span><span class="fl">0.3</span>, color<span class="op">=</span><span class="st">'green'</span>, label<span class="op">=</span><span class="st">'Predicted Anomalies'</span> <span class="cf">if</span> start <span class="op">==</span> predicted_ranges[<span class="dv">0</span>][<span class="dv">0</span>] <span class="cf">else</span> <span class="st">""</span>)</span>
<span id="cb21-273"><a href="#cb21-273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-274"><a href="#cb21-274" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Add accuracy information to title</span></span>
<span id="cb21-275"><a href="#cb21-275" aria-hidden="true" tabindex="-1"></a>    title <span class="op">=</span> <span class="ss">f'File </span><span class="sc">{</span>file_idx<span class="sc">}</span><span class="ss"> - '</span> <span class="cf">if</span> file_idx <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="cf">else</span> <span class="st">''</span></span>
<span id="cb21-276"><a href="#cb21-276" aria-hidden="true" tabindex="-1"></a>    title <span class="op">+=</span> <span class="ss">f'Anomaly Detection (F1: </span><span class="sc">{</span>metrics[<span class="st">"f1_score"</span>]<span class="sc">:.3f}</span><span class="ss">, Target Acc: </span><span class="sc">{</span>metrics[<span class="st">"target_accuracy"</span>]<span class="sc">:.3f}</span><span class="ss">)'</span></span>
<span id="cb21-277"><a href="#cb21-277" aria-hidden="true" tabindex="-1"></a>    title <span class="op">+=</span> <span class="ss">f'</span><span class="ch">\n</span><span class="ss">TP: </span><span class="sc">{</span>metrics[<span class="st">"true_positives"</span>]<span class="sc">}</span><span class="ss">, FP: </span><span class="sc">{</span>metrics[<span class="st">"false_positives"</span>]<span class="sc">}</span><span class="ss">, FN: </span><span class="sc">{</span>metrics[<span class="st">"false_negatives"</span>]<span class="sc">}</span><span class="ss">'</span></span>
<span id="cb21-278"><a href="#cb21-278" aria-hidden="true" tabindex="-1"></a>    title <span class="op">+=</span> <span class="ss">f', Predicted: </span><span class="sc">{</span>metrics[<span class="st">"total_predicted_ranges"</span>]<span class="sc">}</span><span class="ss">, True: </span><span class="sc">{</span>metrics[<span class="st">"total_true_ranges"</span>]<span class="sc">}</span><span class="ss">'</span></span>
<span id="cb21-279"><a href="#cb21-279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-280"><a href="#cb21-280" aria-hidden="true" tabindex="-1"></a>    plt.title(title)</span>
<span id="cb21-281"><a href="#cb21-281" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">'Time Step'</span>)</span>
<span id="cb21-282"><a href="#cb21-282" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">'Value'</span>)</span>
<span id="cb21-283"><a href="#cb21-283" aria-hidden="true" tabindex="-1"></a>    plt.legend()</span>
<span id="cb21-284"><a href="#cb21-284" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb21-285"><a href="#cb21-285" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb21-286"><a href="#cb21-286" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-287"><a href="#cb21-287" aria-hidden="true" tabindex="-1"></a><span class="co"># Enhanced main evaluation loop</span></span>
<span id="cb21-288"><a href="#cb21-288" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Starting Enhanced Isolation Forest Anomaly Detection Evaluation"</span>)</span>
<span id="cb21-289"><a href="#cb21-289" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"TARGET: Detect approximately 10 anomalies in each of the 10 datasets"</span>)</span>
<span id="cb21-290"><a href="#cb21-290" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"="</span> <span class="op">*</span> <span class="dv">70</span>)</span>
<span id="cb21-291"><a href="#cb21-291" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-292"><a href="#cb21-292" aria-hidden="true" tabindex="-1"></a>total_correct <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb21-293"><a href="#cb21-293" aria-hidden="true" tabindex="-1"></a>total_files <span class="op">=</span> <span class="bu">len</span>(test_files)</span>
<span id="cb21-294"><a href="#cb21-294" aria-hidden="true" tabindex="-1"></a>all_metrics <span class="op">=</span> []</span>
<span id="cb21-295"><a href="#cb21-295" aria-hidden="true" tabindex="-1"></a>detailed_results <span class="op">=</span> []</span>
<span id="cb21-296"><a href="#cb21-296" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-297"><a href="#cb21-297" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> idx, test_df <span class="kw">in</span> <span class="bu">enumerate</span>(test_files):</span>
<span id="cb21-298"><a href="#cb21-298" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">--- Processing File </span><span class="sc">{</span>idx<span class="sc">}</span><span class="ss"> ---"</span>)</span>
<span id="cb21-299"><a href="#cb21-299" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-300"><a href="#cb21-300" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb21-301"><a href="#cb21-301" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Extract series and labels</span></span>
<span id="cb21-302"><a href="#cb21-302" aria-hidden="true" tabindex="-1"></a>        series <span class="op">=</span> test_df[<span class="st">'Value'</span>].values <span class="cf">if</span> <span class="st">'Value'</span> <span class="kw">in</span> test_df.columns <span class="cf">else</span> test_df.iloc[:, <span class="dv">0</span>].values</span>
<span id="cb21-303"><a href="#cb21-303" aria-hidden="true" tabindex="-1"></a>        labels <span class="op">=</span> test_df[<span class="st">'Labels'</span>].values <span class="cf">if</span> <span class="st">'Labels'</span> <span class="kw">in</span> test_df.columns <span class="cf">else</span> test_df.iloc[:, <span class="dv">1</span>].values</span>
<span id="cb21-304"><a href="#cb21-304" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-305"><a href="#cb21-305" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Get true anomaly ranges</span></span>
<span id="cb21-306"><a href="#cb21-306" aria-hidden="true" tabindex="-1"></a>        true_ranges <span class="op">=</span> extract_true_anomaly_ranges(labels)</span>
<span id="cb21-307"><a href="#cb21-307" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"True anomaly ranges: </span><span class="sc">{</span>true_ranges<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-308"><a href="#cb21-308" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Number of true anomaly segments: </span><span class="sc">{</span><span class="bu">len</span>(true_ranges)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-309"><a href="#cb21-309" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-310"><a href="#cb21-310" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Detect anomalies using enhanced student's function</span></span>
<span id="cb21-311"><a href="#cb21-311" aria-hidden="true" tabindex="-1"></a>        predicted_ranges <span class="op">=</span> student_detect_anomalies(series)</span>
<span id="cb21-312"><a href="#cb21-312" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Predicted anomaly ranges: </span><span class="sc">{</span>predicted_ranges<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-313"><a href="#cb21-313" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Number of predicted anomaly segments: </span><span class="sc">{</span><span class="bu">len</span>(predicted_ranges)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-314"><a href="#cb21-314" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-315"><a href="#cb21-315" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Evaluate performance with target-based metrics</span></span>
<span id="cb21-316"><a href="#cb21-316" aria-hidden="true" tabindex="-1"></a>        metrics <span class="op">=</span> evaluate_anomaly_detection_enhanced(true_ranges, predicted_ranges, target_anomalies<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb21-317"><a href="#cb21-317" aria-hidden="true" tabindex="-1"></a>        all_metrics.append(metrics)</span>
<span id="cb21-318"><a href="#cb21-318" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-319"><a href="#cb21-319" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Store detailed results</span></span>
<span id="cb21-320"><a href="#cb21-320" aria-hidden="true" tabindex="-1"></a>        detailed_results.append({</span>
<span id="cb21-321"><a href="#cb21-321" aria-hidden="true" tabindex="-1"></a>            <span class="st">'file_idx'</span>: idx,</span>
<span id="cb21-322"><a href="#cb21-322" aria-hidden="true" tabindex="-1"></a>            <span class="st">'true_ranges'</span>: true_ranges,</span>
<span id="cb21-323"><a href="#cb21-323" aria-hidden="true" tabindex="-1"></a>            <span class="st">'predicted_ranges'</span>: predicted_ranges,</span>
<span id="cb21-324"><a href="#cb21-324" aria-hidden="true" tabindex="-1"></a>            <span class="st">'metrics'</span>: metrics</span>
<span id="cb21-325"><a href="#cb21-325" aria-hidden="true" tabindex="-1"></a>        })</span>
<span id="cb21-326"><a href="#cb21-326" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-327"><a href="#cb21-327" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Count correct detections (at least one true positive)</span></span>
<span id="cb21-328"><a href="#cb21-328" aria-hidden="true" tabindex="-1"></a>        correct_this_file <span class="op">=</span> metrics[<span class="st">'detection_success'</span>]</span>
<span id="cb21-329"><a href="#cb21-329" aria-hidden="true" tabindex="-1"></a>        total_correct <span class="op">+=</span> correct_this_file</span>
<span id="cb21-330"><a href="#cb21-330" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-331"><a href="#cb21-331" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"True Positives: </span><span class="sc">{</span>metrics[<span class="st">'true_positives'</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-332"><a href="#cb21-332" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"False Positives: </span><span class="sc">{</span>metrics[<span class="st">'false_positives'</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-333"><a href="#cb21-333" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"False Negatives: </span><span class="sc">{</span>metrics[<span class="st">'false_negatives'</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-334"><a href="#cb21-334" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Precision: </span><span class="sc">{</span>metrics[<span class="st">'precision'</span>]<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb21-335"><a href="#cb21-335" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Recall: </span><span class="sc">{</span>metrics[<span class="st">'recall'</span>]<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb21-336"><a href="#cb21-336" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"F1-Score: </span><span class="sc">{</span>metrics[<span class="st">'f1_score'</span>]<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb21-337"><a href="#cb21-337" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Target Accuracy: </span><span class="sc">{</span>metrics[<span class="st">'target_accuracy'</span>]<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb21-338"><a href="#cb21-338" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Combined Score: </span><span class="sc">{</span>metrics[<span class="st">'combined_score'</span>]<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb21-339"><a href="#cb21-339" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"File </span><span class="sc">{</span>idx<span class="sc">}</span><span class="ss"> Detection Success: </span><span class="sc">{</span>correct_this_file<span class="sc">}</span><span class="ss">/1"</span>)</span>
<span id="cb21-340"><a href="#cb21-340" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-341"><a href="#cb21-341" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb21-342"><a href="#cb21-342" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Error processing file </span><span class="sc">{</span>idx<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-343"><a href="#cb21-343" aria-hidden="true" tabindex="-1"></a>        <span class="im">import</span> traceback</span>
<span id="cb21-344"><a href="#cb21-344" aria-hidden="true" tabindex="-1"></a>        traceback.print_exc()</span>
<span id="cb21-345"><a href="#cb21-345" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add zero metrics for failed files</span></span>
<span id="cb21-346"><a href="#cb21-346" aria-hidden="true" tabindex="-1"></a>        all_metrics.append({</span>
<span id="cb21-347"><a href="#cb21-347" aria-hidden="true" tabindex="-1"></a>            <span class="st">'true_positives'</span>: <span class="dv">0</span>,</span>
<span id="cb21-348"><a href="#cb21-348" aria-hidden="true" tabindex="-1"></a>            <span class="st">'false_positives'</span>: <span class="dv">0</span>,</span>
<span id="cb21-349"><a href="#cb21-349" aria-hidden="true" tabindex="-1"></a>            <span class="st">'false_negatives'</span>: <span class="bu">len</span>(true_ranges) <span class="cf">if</span> <span class="st">'true_ranges'</span> <span class="kw">in</span> <span class="bu">locals</span>() <span class="cf">else</span> <span class="dv">0</span>,</span>
<span id="cb21-350"><a href="#cb21-350" aria-hidden="true" tabindex="-1"></a>            <span class="st">'precision'</span>: <span class="dv">0</span>,</span>
<span id="cb21-351"><a href="#cb21-351" aria-hidden="true" tabindex="-1"></a>            <span class="st">'recall'</span>: <span class="dv">0</span>,</span>
<span id="cb21-352"><a href="#cb21-352" aria-hidden="true" tabindex="-1"></a>            <span class="st">'f1_score'</span>: <span class="dv">0</span>,</span>
<span id="cb21-353"><a href="#cb21-353" aria-hidden="true" tabindex="-1"></a>            <span class="st">'target_accuracy'</span>: <span class="dv">0</span>,</span>
<span id="cb21-354"><a href="#cb21-354" aria-hidden="true" tabindex="-1"></a>            <span class="st">'combined_score'</span>: <span class="dv">0</span>,</span>
<span id="cb21-355"><a href="#cb21-355" aria-hidden="true" tabindex="-1"></a>            <span class="st">'detection_success'</span>: <span class="dv">0</span>,</span>
<span id="cb21-356"><a href="#cb21-356" aria-hidden="true" tabindex="-1"></a>            <span class="st">'total_predicted_ranges'</span>: <span class="dv">0</span>,</span>
<span id="cb21-357"><a href="#cb21-357" aria-hidden="true" tabindex="-1"></a>            <span class="st">'total_true_ranges'</span>: <span class="bu">len</span>(true_ranges) <span class="cf">if</span> <span class="st">'true_ranges'</span> <span class="kw">in</span> <span class="bu">locals</span>() <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb21-358"><a href="#cb21-358" aria-hidden="true" tabindex="-1"></a>        })</span>
<span id="cb21-359"><a href="#cb21-359" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-360"><a href="#cb21-360" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate overall scores with enhanced metrics</span></span>
<span id="cb21-361"><a href="#cb21-361" aria-hidden="true" tabindex="-1"></a>overall_precision <span class="op">=</span> np.mean([m[<span class="st">'precision'</span>] <span class="cf">for</span> m <span class="kw">in</span> all_metrics])</span>
<span id="cb21-362"><a href="#cb21-362" aria-hidden="true" tabindex="-1"></a>overall_recall <span class="op">=</span> np.mean([m[<span class="st">'recall'</span>] <span class="cf">for</span> m <span class="kw">in</span> all_metrics])</span>
<span id="cb21-363"><a href="#cb21-363" aria-hidden="true" tabindex="-1"></a>overall_f1 <span class="op">=</span> np.mean([m[<span class="st">'f1_score'</span>] <span class="cf">for</span> m <span class="kw">in</span> all_metrics])</span>
<span id="cb21-364"><a href="#cb21-364" aria-hidden="true" tabindex="-1"></a>overall_target_accuracy <span class="op">=</span> np.mean([m[<span class="st">'target_accuracy'</span>] <span class="cf">for</span> m <span class="kw">in</span> all_metrics])</span>
<span id="cb21-365"><a href="#cb21-365" aria-hidden="true" tabindex="-1"></a>overall_combined_score <span class="op">=</span> np.mean([m[<span class="st">'combined_score'</span>] <span class="cf">for</span> m <span class="kw">in</span> all_metrics])</span>
<span id="cb21-366"><a href="#cb21-366" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-367"><a href="#cb21-367" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span> <span class="op">+</span> <span class="st">"="</span> <span class="op">*</span> <span class="dv">70</span>)</span>
<span id="cb21-368"><a href="#cb21-368" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"FINAL ENHANCED RESULTS FOR ALL TEST FILES"</span>)</span>
<span id="cb21-369"><a href="#cb21-369" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"="</span> <span class="op">*</span> <span class="dv">70</span>)</span>
<span id="cb21-370"><a href="#cb21-370" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Total files processed: </span><span class="sc">{</span>total_files<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-371"><a href="#cb21-371" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Total correct files: </span><span class="sc">{</span>total_correct<span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>total_files<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-372"><a href="#cb21-372" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Detection Accuracy: </span><span class="sc">{</span>(total_correct<span class="op">/</span>total_files)<span class="op">*</span><span class="dv">100</span><span class="sc">:.2f}</span><span class="ss">%"</span>)</span>
<span id="cb21-373"><a href="#cb21-373" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Overall Precision: </span><span class="sc">{</span>overall_precision<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb21-374"><a href="#cb21-374" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Overall Recall: </span><span class="sc">{</span>overall_recall<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb21-375"><a href="#cb21-375" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Overall F1-Score: </span><span class="sc">{</span>overall_f1<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb21-376"><a href="#cb21-376" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Overall Target Accuracy: </span><span class="sc">{</span>overall_target_accuracy<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb21-377"><a href="#cb21-377" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Overall Combined Score: </span><span class="sc">{</span>overall_combined_score<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb21-378"><a href="#cb21-378" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-379"><a href="#cb21-379" aria-hidden="true" tabindex="-1"></a><span class="co"># Enhanced detailed results display</span></span>
<span id="cb21-380"><a href="#cb21-380" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span> <span class="op">+</span> <span class="st">"="</span> <span class="op">*</span> <span class="dv">70</span>)</span>
<span id="cb21-381"><a href="#cb21-381" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"DETAILED ENHANCED RESULTS BY FILE"</span>)</span>
<span id="cb21-382"><a href="#cb21-382" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"="</span> <span class="op">*</span> <span class="dv">70</span>)</span>
<span id="cb21-383"><a href="#cb21-383" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> result <span class="kw">in</span> detailed_results:</span>
<span id="cb21-384"><a href="#cb21-384" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> result[<span class="st">'metrics'</span>]</span>
<span id="cb21-385"><a href="#cb21-385" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">File </span><span class="sc">{</span>result[<span class="st">'file_idx'</span>]<span class="sc">}</span><span class="ss">:"</span>)</span>
<span id="cb21-386"><a href="#cb21-386" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  True Ranges: </span><span class="sc">{</span>result[<span class="st">'true_ranges'</span>]<span class="sc">}</span><span class="ss"> (count: </span><span class="sc">{</span><span class="bu">len</span>(result[<span class="st">'true_ranges'</span>])<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb21-387"><a href="#cb21-387" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Predicted Ranges: </span><span class="sc">{</span>result[<span class="st">'predicted_ranges'</span>]<span class="sc">}</span><span class="ss"> (count: </span><span class="sc">{</span><span class="bu">len</span>(result[<span class="st">'predicted_ranges'</span>])<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb21-388"><a href="#cb21-388" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Precision: </span><span class="sc">{</span>m[<span class="st">'precision'</span>]<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb21-389"><a href="#cb21-389" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Recall: </span><span class="sc">{</span>m[<span class="st">'recall'</span>]<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb21-390"><a href="#cb21-390" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  F1-Score: </span><span class="sc">{</span>m[<span class="st">'f1_score'</span>]<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb21-391"><a href="#cb21-391" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Target Accuracy: </span><span class="sc">{</span>m[<span class="st">'target_accuracy'</span>]<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb21-392"><a href="#cb21-392" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Combined Score: </span><span class="sc">{</span>m[<span class="st">'combined_score'</span>]<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb21-393"><a href="#cb21-393" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Detection Success: </span><span class="sc">{</span>m[<span class="st">'detection_success'</span>]<span class="sc">}</span><span class="ss">/1"</span>)</span>
<span id="cb21-394"><a href="#cb21-394" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-395"><a href="#cb21-395" aria-hidden="true" tabindex="-1"></a><span class="co"># Enhanced visualization for ALL files</span></span>
<span id="cb21-396"><a href="#cb21-396" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Visualizing enhanced results for ALL files..."</span>)</span>
<span id="cb21-397"><a href="#cb21-397" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> idx, test_df <span class="kw">in</span> <span class="bu">enumerate</span>(test_files):</span>
<span id="cb21-398"><a href="#cb21-398" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb21-399"><a href="#cb21-399" aria-hidden="true" tabindex="-1"></a>        series <span class="op">=</span> test_df[<span class="st">'Value'</span>].values <span class="cf">if</span> <span class="st">'Value'</span> <span class="kw">in</span> test_df.columns <span class="cf">else</span> test_df.iloc[:, <span class="dv">0</span>].values</span>
<span id="cb21-400"><a href="#cb21-400" aria-hidden="true" tabindex="-1"></a>        labels <span class="op">=</span> test_df[<span class="st">'Labels'</span>].values <span class="cf">if</span> <span class="st">'Labels'</span> <span class="kw">in</span> test_df.columns <span class="cf">else</span> test_df.iloc[:, <span class="dv">1</span>].values</span>
<span id="cb21-401"><a href="#cb21-401" aria-hidden="true" tabindex="-1"></a>        true_ranges <span class="op">=</span> extract_true_anomaly_ranges(labels)</span>
<span id="cb21-402"><a href="#cb21-402" aria-hidden="true" tabindex="-1"></a>        predicted_ranges <span class="op">=</span> student_detect_anomalies(series)</span>
<span id="cb21-403"><a href="#cb21-403" aria-hidden="true" tabindex="-1"></a>        metrics <span class="op">=</span> evaluate_anomaly_detection_enhanced(true_ranges, predicted_ranges, target_anomalies<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb21-404"><a href="#cb21-404" aria-hidden="true" tabindex="-1"></a>        visualize_anomaly_detection_with_accuracy(test_df, predicted_ranges, metrics, file_idx<span class="op">=</span>idx)</span>
<span id="cb21-405"><a href="#cb21-405" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb21-406"><a href="#cb21-406" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Error visualizing file </span><span class="sc">{</span>idx<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb21-407"><a href="#cb21-407" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-408"><a href="#cb21-408" aria-hidden="true" tabindex="-1"></a><span class="co"># Create comprehensive summary visualization</span></span>
<span id="cb21-409"><a href="#cb21-409" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Creating comprehensive performance summary..."</span>)</span>
<span id="cb21-410"><a href="#cb21-410" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">16</span>, <span class="dv">12</span>))</span>
<span id="cb21-411"><a href="#cb21-411" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-412"><a href="#cb21-412" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot 1: Overall performance metrics</span></span>
<span id="cb21-413"><a href="#cb21-413" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">1</span>)</span>
<span id="cb21-414"><a href="#cb21-414" aria-hidden="true" tabindex="-1"></a>metrics_names <span class="op">=</span> [<span class="st">'Precision'</span>, <span class="st">'Recall'</span>, <span class="st">'F1-Score'</span>, <span class="st">'Target Acc'</span>, <span class="st">'Combined'</span>]</span>
<span id="cb21-415"><a href="#cb21-415" aria-hidden="true" tabindex="-1"></a>metrics_values <span class="op">=</span> [overall_precision, overall_recall, overall_f1, overall_target_accuracy, overall_combined_score]</span>
<span id="cb21-416"><a href="#cb21-416" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [<span class="st">'blue'</span>, <span class="st">'green'</span>, <span class="st">'red'</span>, <span class="st">'purple'</span>, <span class="st">'orange'</span>]</span>
<span id="cb21-417"><a href="#cb21-417" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-418"><a href="#cb21-418" aria-hidden="true" tabindex="-1"></a>plt.bar(metrics_names, metrics_values, color<span class="op">=</span>colors)</span>
<span id="cb21-419"><a href="#cb21-419" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Overall Performance Metrics'</span>)</span>
<span id="cb21-420"><a href="#cb21-420" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb21-421"><a href="#cb21-421" aria-hidden="true" tabindex="-1"></a>plt.xticks(rotation<span class="op">=</span><span class="dv">45</span>)</span>
<span id="cb21-422"><a href="#cb21-422" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, v <span class="kw">in</span> <span class="bu">enumerate</span>(metrics_values):</span>
<span id="cb21-423"><a href="#cb21-423" aria-hidden="true" tabindex="-1"></a>    plt.text(i, v <span class="op">+</span> <span class="fl">0.01</span>, <span class="ss">f'</span><span class="sc">{</span>v<span class="sc">:.3f}</span><span class="ss">'</span>, ha<span class="op">=</span><span class="st">'center'</span>, va<span class="op">=</span><span class="st">'bottom'</span>)</span>
<span id="cb21-424"><a href="#cb21-424" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-425"><a href="#cb21-425" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot 2: Per-file F1 scores</span></span>
<span id="cb21-426"><a href="#cb21-426" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">2</span>)</span>
<span id="cb21-427"><a href="#cb21-427" aria-hidden="true" tabindex="-1"></a>file_indices <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(total_files))</span>
<span id="cb21-428"><a href="#cb21-428" aria-hidden="true" tabindex="-1"></a>f1_scores <span class="op">=</span> [m[<span class="st">'f1_score'</span>] <span class="cf">for</span> m <span class="kw">in</span> all_metrics]</span>
<span id="cb21-429"><a href="#cb21-429" aria-hidden="true" tabindex="-1"></a>plt.bar(file_indices, f1_scores, color<span class="op">=</span><span class="st">'orange'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb21-430"><a href="#cb21-430" aria-hidden="true" tabindex="-1"></a>plt.axhline(y<span class="op">=</span>overall_f1, color<span class="op">=</span><span class="st">'red'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="ss">f'Average: </span><span class="sc">{</span>overall_f1<span class="sc">:.3f}</span><span class="ss">'</span>)</span>
<span id="cb21-431"><a href="#cb21-431" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'F1-Score by File'</span>)</span>
<span id="cb21-432"><a href="#cb21-432" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'File Index'</span>)</span>
<span id="cb21-433"><a href="#cb21-433" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'F1-Score'</span>)</span>
<span id="cb21-434"><a href="#cb21-434" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb21-435"><a href="#cb21-435" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb21-436"><a href="#cb21-436" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-437"><a href="#cb21-437" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot 3: Per-file target accuracy</span></span>
<span id="cb21-438"><a href="#cb21-438" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">3</span>)</span>
<span id="cb21-439"><a href="#cb21-439" aria-hidden="true" tabindex="-1"></a>target_accuracies <span class="op">=</span> [m[<span class="st">'target_accuracy'</span>] <span class="cf">for</span> m <span class="kw">in</span> all_metrics]</span>
<span id="cb21-440"><a href="#cb21-440" aria-hidden="true" tabindex="-1"></a>plt.bar(file_indices, target_accuracies, color<span class="op">=</span><span class="st">'purple'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb21-441"><a href="#cb21-441" aria-hidden="true" tabindex="-1"></a>plt.axhline(y<span class="op">=</span>overall_target_accuracy, color<span class="op">=</span><span class="st">'red'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="ss">f'Average: </span><span class="sc">{</span>overall_target_accuracy<span class="sc">:.3f}</span><span class="ss">'</span>)</span>
<span id="cb21-442"><a href="#cb21-442" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Target Accuracy by File'</span>)</span>
<span id="cb21-443"><a href="#cb21-443" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'File Index'</span>)</span>
<span id="cb21-444"><a href="#cb21-444" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Target Accuracy'</span>)</span>
<span id="cb21-445"><a href="#cb21-445" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb21-446"><a href="#cb21-446" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb21-447"><a href="#cb21-447" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-448"><a href="#cb21-448" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot 4: Detection summary</span></span>
<span id="cb21-449"><a href="#cb21-449" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">4</span>)</span>
<span id="cb21-450"><a href="#cb21-450" aria-hidden="true" tabindex="-1"></a>total_tp <span class="op">=</span> <span class="bu">sum</span>([m[<span class="st">'true_positives'</span>] <span class="cf">for</span> m <span class="kw">in</span> all_metrics])</span>
<span id="cb21-451"><a href="#cb21-451" aria-hidden="true" tabindex="-1"></a>total_fp <span class="op">=</span> <span class="bu">sum</span>([m[<span class="st">'false_positives'</span>] <span class="cf">for</span> m <span class="kw">in</span> all_metrics])</span>
<span id="cb21-452"><a href="#cb21-452" aria-hidden="true" tabindex="-1"></a>total_fn <span class="op">=</span> <span class="bu">sum</span>([m[<span class="st">'false_negatives'</span>] <span class="cf">for</span> m <span class="kw">in</span> all_metrics])</span>
<span id="cb21-453"><a href="#cb21-453" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-454"><a href="#cb21-454" aria-hidden="true" tabindex="-1"></a>detection_types <span class="op">=</span> [<span class="st">'True Positives'</span>, <span class="st">'False Positives'</span>, <span class="st">'False Negatives'</span>]</span>
<span id="cb21-455"><a href="#cb21-455" aria-hidden="true" tabindex="-1"></a>detection_counts <span class="op">=</span> [total_tp, total_fp, total_fn]</span>
<span id="cb21-456"><a href="#cb21-456" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [<span class="st">'green'</span>, <span class="st">'red'</span>, <span class="st">'orange'</span>]</span>
<span id="cb21-457"><a href="#cb21-457" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-458"><a href="#cb21-458" aria-hidden="true" tabindex="-1"></a>plt.bar(detection_types, detection_counts, color<span class="op">=</span>colors)</span>
<span id="cb21-459"><a href="#cb21-459" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Overall Detection Summary'</span>)</span>
<span id="cb21-460"><a href="#cb21-460" aria-hidden="true" tabindex="-1"></a>plt.xticks(rotation<span class="op">=</span><span class="dv">45</span>)</span>
<span id="cb21-461"><a href="#cb21-461" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, v <span class="kw">in</span> <span class="bu">enumerate</span>(detection_counts):</span>
<span id="cb21-462"><a href="#cb21-462" aria-hidden="true" tabindex="-1"></a>    plt.text(i, v <span class="op">+</span> <span class="fl">0.1</span>, <span class="bu">str</span>(v), ha<span class="op">=</span><span class="st">'center'</span>, va<span class="op">=</span><span class="st">'bottom'</span>)</span>
<span id="cb21-463"><a href="#cb21-463" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-464"><a href="#cb21-464" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot 5: File-wise detection success</span></span>
<span id="cb21-465"><a href="#cb21-465" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">5</span>)</span>
<span id="cb21-466"><a href="#cb21-466" aria-hidden="true" tabindex="-1"></a>file_scores <span class="op">=</span> [m[<span class="st">'detection_success'</span>] <span class="cf">for</span> m <span class="kw">in</span> all_metrics]</span>
<span id="cb21-467"><a href="#cb21-467" aria-hidden="true" tabindex="-1"></a>colors <span class="op">=</span> [<span class="st">'red'</span> <span class="cf">if</span> score <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="st">'green'</span> <span class="cf">for</span> score <span class="kw">in</span> file_scores]</span>
<span id="cb21-468"><a href="#cb21-468" aria-hidden="true" tabindex="-1"></a>plt.bar(file_indices, file_scores, color<span class="op">=</span>colors)</span>
<span id="cb21-469"><a href="#cb21-469" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'File-wise Detection Success (1=Success, 0=Failure)'</span>)</span>
<span id="cb21-470"><a href="#cb21-470" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'File Index'</span>)</span>
<span id="cb21-471"><a href="#cb21-471" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Detection Success'</span>)</span>
<span id="cb21-472"><a href="#cb21-472" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb21-473"><a href="#cb21-473" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-474"><a href="#cb21-474" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot 6: Predicted vs Target ranges</span></span>
<span id="cb21-475"><a href="#cb21-475" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">6</span>)</span>
<span id="cb21-476"><a href="#cb21-476" aria-hidden="true" tabindex="-1"></a>predicted_counts <span class="op">=</span> [m[<span class="st">'total_predicted_ranges'</span>] <span class="cf">for</span> m <span class="kw">in</span> all_metrics]</span>
<span id="cb21-477"><a href="#cb21-477" aria-hidden="true" tabindex="-1"></a>target_line <span class="op">=</span> [<span class="dv">10</span>] <span class="op">*</span> total_files  <span class="co"># Target of 10 anomalies per file</span></span>
<span id="cb21-478"><a href="#cb21-478" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-479"><a href="#cb21-479" aria-hidden="true" tabindex="-1"></a>plt.plot(file_indices, predicted_counts, <span class="st">'bo-'</span>, label<span class="op">=</span><span class="st">'Predicted Ranges'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb21-480"><a href="#cb21-480" aria-hidden="true" tabindex="-1"></a>plt.plot(file_indices, target_line, <span class="st">'r--'</span>, label<span class="op">=</span><span class="st">'Target (10)'</span>, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb21-481"><a href="#cb21-481" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Predicted vs Target Anomaly Ranges'</span>)</span>
<span id="cb21-482"><a href="#cb21-482" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'File Index'</span>)</span>
<span id="cb21-483"><a href="#cb21-483" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Number of Ranges'</span>)</span>
<span id="cb21-484"><a href="#cb21-484" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb21-485"><a href="#cb21-485" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-486"><a href="#cb21-486" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot 7: Combined score by file</span></span>
<span id="cb21-487"><a href="#cb21-487" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">7</span>)</span>
<span id="cb21-488"><a href="#cb21-488" aria-hidden="true" tabindex="-1"></a>combined_scores <span class="op">=</span> [m[<span class="st">'combined_score'</span>] <span class="cf">for</span> m <span class="kw">in</span> all_metrics]</span>
<span id="cb21-489"><a href="#cb21-489" aria-hidden="true" tabindex="-1"></a>plt.bar(file_indices, combined_scores, color<span class="op">=</span><span class="st">'orange'</span>, alpha<span class="op">=</span><span class="fl">0.7</span>)</span>
<span id="cb21-490"><a href="#cb21-490" aria-hidden="true" tabindex="-1"></a>plt.axhline(y<span class="op">=</span>overall_combined_score, color<span class="op">=</span><span class="st">'red'</span>, linestyle<span class="op">=</span><span class="st">'--'</span>, label<span class="op">=</span><span class="ss">f'Average: </span><span class="sc">{</span>overall_combined_score<span class="sc">:.3f}</span><span class="ss">'</span>)</span>
<span id="cb21-491"><a href="#cb21-491" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Combined Score by File'</span>)</span>
<span id="cb21-492"><a href="#cb21-492" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'File Index'</span>)</span>
<span id="cb21-493"><a href="#cb21-493" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Combined Score'</span>)</span>
<span id="cb21-494"><a href="#cb21-494" aria-hidden="true" tabindex="-1"></a>plt.ylim(<span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb21-495"><a href="#cb21-495" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb21-496"><a href="#cb21-496" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-497"><a href="#cb21-497" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb21-498"><a href="#cb21-498" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb21-499"><a href="#cb21-499" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-500"><a href="#cb21-500" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Enhanced anomaly detection completed for all test files!"</span>)</span>
<span id="cb21-501"><a href="#cb21-501" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Final Summary: </span><span class="sc">{</span>total_correct<span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>total_files<span class="sc">}</span><span class="ss"> files successfully detected anomalies"</span>)</span>
<span id="cb21-502"><a href="#cb21-502" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Overall performance score: </span><span class="sc">{</span>overall_combined_score<span class="sc">:.4f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Starting Enhanced Isolation Forest Anomaly Detection Evaluation
TARGET: Detect approximately 10 anomalies in each of the 10 datasets
======================================================================

--- Processing File 0 ---
Error processing file 0: name 'extract_true_anomaly_ranges' is not defined

--- Processing File 1 ---
Error processing file 1: name 'extract_true_anomaly_ranges' is not defined

--- Processing File 2 ---
Error processing file 2: name 'extract_true_anomaly_ranges' is not defined

--- Processing File 3 ---
Error processing file 3: name 'extract_true_anomaly_ranges' is not defined

--- Processing File 4 ---
Error processing file 4: name 'extract_true_anomaly_ranges' is not defined

--- Processing File 5 ---
Error processing file 5: name 'extract_true_anomaly_ranges' is not defined

--- Processing File 6 ---
Error processing file 6: name 'extract_true_anomaly_ranges' is not defined

--- Processing File 7 ---
Error processing file 7: name 'extract_true_anomaly_ranges' is not defined

--- Processing File 8 ---
Error processing file 8: name 'extract_true_anomaly_ranges' is not defined

--- Processing File 9 ---
Error processing file 9: name 'extract_true_anomaly_ranges' is not defined

======================================================================
FINAL ENHANCED RESULTS FOR ALL TEST FILES
======================================================================
Total files processed: 10
Total correct files: 0/10
Detection Accuracy: 0.00%
Overall Precision: 0.0000
Overall Recall: 0.0000
Overall F1-Score: 0.0000
Overall Target Accuracy: 0.0000
Overall Combined Score: 0.0000

======================================================================
DETAILED ENHANCED RESULTS BY FILE
======================================================================

Visualizing enhanced results for ALL files...
Error visualizing file 0: name 'extract_true_anomaly_ranges' is not defined
Error visualizing file 1: name 'extract_true_anomaly_ranges' is not defined
Error visualizing file 2: name 'extract_true_anomaly_ranges' is not defined
Error visualizing file 3: name 'extract_true_anomaly_ranges' is not defined
Error visualizing file 4: name 'extract_true_anomaly_ranges' is not defined
Error visualizing file 5: name 'extract_true_anomaly_ranges' is not defined
Error visualizing file 6: name 'extract_true_anomaly_ranges' is not defined
Error visualizing file 7: name 'extract_true_anomaly_ranges' is not defined
Error visualizing file 8: name 'extract_true_anomaly_ranges' is not defined
Error visualizing file 9: name 'extract_true_anomaly_ranges' is not defined

Creating comprehensive performance summary...</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Traceback (most recent call last):
  File "/tmp/ipykernel_43524/860436678.py", line 306, in &lt;module&gt;
    true_ranges = extract_true_anomaly_ranges(labels)
NameError: name 'extract_true_anomaly_ranges' is not defined
Traceback (most recent call last):
  File "/tmp/ipykernel_43524/860436678.py", line 306, in &lt;module&gt;
    true_ranges = extract_true_anomaly_ranges(labels)
NameError: name 'extract_true_anomaly_ranges' is not defined
Traceback (most recent call last):
  File "/tmp/ipykernel_43524/860436678.py", line 306, in &lt;module&gt;
    true_ranges = extract_true_anomaly_ranges(labels)
NameError: name 'extract_true_anomaly_ranges' is not defined
Traceback (most recent call last):
  File "/tmp/ipykernel_43524/860436678.py", line 306, in &lt;module&gt;
    true_ranges = extract_true_anomaly_ranges(labels)
NameError: name 'extract_true_anomaly_ranges' is not defined
Traceback (most recent call last):
  File "/tmp/ipykernel_43524/860436678.py", line 306, in &lt;module&gt;
    true_ranges = extract_true_anomaly_ranges(labels)
NameError: name 'extract_true_anomaly_ranges' is not defined
Traceback (most recent call last):
  File "/tmp/ipykernel_43524/860436678.py", line 306, in &lt;module&gt;
    true_ranges = extract_true_anomaly_ranges(labels)
NameError: name 'extract_true_anomaly_ranges' is not defined
Traceback (most recent call last):
  File "/tmp/ipykernel_43524/860436678.py", line 306, in &lt;module&gt;
    true_ranges = extract_true_anomaly_ranges(labels)
NameError: name 'extract_true_anomaly_ranges' is not defined
Traceback (most recent call last):
  File "/tmp/ipykernel_43524/860436678.py", line 306, in &lt;module&gt;
    true_ranges = extract_true_anomaly_ranges(labels)
NameError: name 'extract_true_anomaly_ranges' is not defined
Traceback (most recent call last):
  File "/tmp/ipykernel_43524/860436678.py", line 306, in &lt;module&gt;
    true_ranges = extract_true_anomaly_ranges(labels)
NameError: name 'extract_true_anomaly_ranges' is not defined
Traceback (most recent call last):
  File "/tmp/ipykernel_43524/860436678.py", line 306, in &lt;module&gt;
    true_ranges = extract_true_anomaly_ranges(labels)
NameError: name 'extract_true_anomaly_ranges' is not defined</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-17-output-3.png" width="1526" height="1142" class="figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Enhanced anomaly detection completed for all test files!
Final Summary: 0/10 files successfully detected anomalies
Overall performance score: 0.0000</code></pre>
</div>
</div>
<p>#Isolation Forest and Z-score Hybrid Model</p>
<p>###Data Processing &amp; Feature Engineering Extracts true anomaly ranges from label arrays using extract_true_anomaly_ranges()</p>
<p>Creates enhanced features including:</p>
<p>Original time series values</p>
<p>Multiple rolling window statistics (mean, std, min, max) across different window sizes</p>
<p>Z-scores based on rolling statistics</p>
<p>Global statistics (mean, std, z-score)</p>
<p>Rate of change and second derivatives</p>
<p>Differences from rolling means</p>
<section id="anomaly-detection-methods" class="level3">
<h3 class="anchored" data-anchor-id="anomaly-detection-methods">Anomaly Detection Methods</h3>
<section id="primary-high-precision-isolation-forest" class="level4">
<h4 class="anchored" data-anchor-id="primary-high-precision-isolation-forest">Primary: High-Precision Isolation Forest</h4>
<p>Uses lower contamination range (0.05-0.2) for fewer false positives</p>
<p>Optimizes contamination parameter specifically for precision</p>
<p>Enhanced configuration: 150 estimators, smaller samples, feature subsetting</p>
<p>Anti-overfitting measures: max_samples=128, max_features=0.7</p>
</section>
<section id="secondary-statistical-z-score-detection" class="level4">
<h4 class="anchored" data-anchor-id="secondary-statistical-z-score-detection">Secondary: Statistical Z-Score Detection</h4>
<p>Maintains Z-score threshold at 3.0 standard deviations</p>
<p>Uses stricter range grouping with minimum 3 consecutive points</p>
<p>Only keeps substantial anomaly ranges</p>
</section>
</section>
<section id="range-processing-grouping" class="level3">
<h3 class="anchored" data-anchor-id="range-processing-grouping">Range Processing &amp; Grouping</h3>
<p>Stricter range grouping: Maximum 5-point gaps between anomalies (was 10)</p>
<p>Minimum length requirement: 3+ consecutive anomalies to form a range</p>
<p>Selective range combination: Only keeps substantial ranges from both methods</p>
<p>Conservative merging: Smaller merge distance (10 points)</p>
<div id="c69f3d8f" class="cell" data-quarto-private-1="{&quot;key&quot;:&quot;colab&quot;,&quot;value&quot;:{&quot;base_uri&quot;:&quot;https://localhost:8080/&quot;}}" data-execution_count="17">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract true anomaly ranges from labels</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> extract_true_anomaly_ranges(labels):</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Extract contiguous anomaly ranges from label array"""</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    labels <span class="op">=</span> np.array(labels)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    anomaly_indices <span class="op">=</span> np.where(labels <span class="op">==</span> <span class="dv">1</span>)[<span class="dv">0</span>]</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(anomaly_indices) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> []</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    ranges <span class="op">=</span> []</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    start <span class="op">=</span> anomaly_indices[<span class="dv">0</span>]</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    end <span class="op">=</span> anomaly_indices[<span class="dv">0</span>]</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(anomaly_indices)):</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> anomaly_indices[i] <span class="op">==</span> anomaly_indices[i<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span>:</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>            end <span class="op">=</span> anomaly_indices[i]</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>            ranges.append((start, end))</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>            start <span class="op">=</span> anomaly_indices[i]</span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>            end <span class="op">=</span> anomaly_indices[i]</span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>    ranges.append((start, end))</span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ranges</span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a><span class="co"># High Precision Isolation Forest Anomaly Detector (Z-score threshold = 3.0)</span></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> HighPrecisionIsolationForestDetector:</span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, contamination_range<span class="op">=</span>(<span class="fl">0.05</span>, <span class="fl">0.2</span>), random_state<span class="op">=</span><span class="dv">42</span>):  <span class="co"># REDUCED range</span></span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.contamination_range <span class="op">=</span> contamination_range  <span class="co"># Lower: 0.05-0.2</span></span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.random_state <span class="op">=</span> random_state</span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.scaler <span class="op">=</span> StandardScaler()</span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.model <span class="op">=</span> <span class="va">None</span></span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.anomaly_windows <span class="op">=</span> []</span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> create_enhanced_features(<span class="va">self</span>, series, window_sizes<span class="op">=</span>[<span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">50</span>, <span class="dv">100</span>]):</span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Enhanced feature engineering with multiple statistical features"""</span></span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true" tabindex="-1"></a>        series <span class="op">=</span> np.array(series).flatten()  <span class="co"># Ensure 1D array</span></span>
<span id="cb25-37"><a href="#cb25-37" aria-hidden="true" tabindex="-1"></a>        features <span class="op">=</span> []</span>
<span id="cb25-38"><a href="#cb25-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-39"><a href="#cb25-39" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Original series (reshape to 2D for stacking)</span></span>
<span id="cb25-40"><a href="#cb25-40" aria-hidden="true" tabindex="-1"></a>        features.append(series.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb25-41"><a href="#cb25-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-42"><a href="#cb25-42" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Multiple rolling window statistics</span></span>
<span id="cb25-43"><a href="#cb25-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> window <span class="kw">in</span> window_sizes:</span>
<span id="cb25-44"><a href="#cb25-44" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">len</span>(series) <span class="op">&gt;=</span> window:</span>
<span id="cb25-45"><a href="#cb25-45" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Rolling statistics</span></span>
<span id="cb25-46"><a href="#cb25-46" aria-hidden="true" tabindex="-1"></a>                roll_mean <span class="op">=</span> pd.Series(series).rolling(window<span class="op">=</span>window, center<span class="op">=</span><span class="va">True</span>).mean().values.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb25-47"><a href="#cb25-47" aria-hidden="true" tabindex="-1"></a>                roll_std <span class="op">=</span> pd.Series(series).rolling(window<span class="op">=</span>window, center<span class="op">=</span><span class="va">True</span>).std().values.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb25-48"><a href="#cb25-48" aria-hidden="true" tabindex="-1"></a>                roll_min <span class="op">=</span> pd.Series(series).rolling(window<span class="op">=</span>window, center<span class="op">=</span><span class="va">True</span>).<span class="bu">min</span>().values.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb25-49"><a href="#cb25-49" aria-hidden="true" tabindex="-1"></a>                roll_max <span class="op">=</span> pd.Series(series).rolling(window<span class="op">=</span>window, center<span class="op">=</span><span class="va">True</span>).<span class="bu">max</span>().values.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb25-50"><a href="#cb25-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-51"><a href="#cb25-51" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Handle NaN values</span></span>
<span id="cb25-52"><a href="#cb25-52" aria-hidden="true" tabindex="-1"></a>                roll_mean <span class="op">=</span> np.nan_to_num(roll_mean)</span>
<span id="cb25-53"><a href="#cb25-53" aria-hidden="true" tabindex="-1"></a>                roll_std <span class="op">=</span> np.nan_to_num(roll_std)</span>
<span id="cb25-54"><a href="#cb25-54" aria-hidden="true" tabindex="-1"></a>                roll_min <span class="op">=</span> np.nan_to_num(roll_min)</span>
<span id="cb25-55"><a href="#cb25-55" aria-hidden="true" tabindex="-1"></a>                roll_max <span class="op">=</span> np.nan_to_num(roll_max)</span>
<span id="cb25-56"><a href="#cb25-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-57"><a href="#cb25-57" aria-hidden="true" tabindex="-1"></a>                features.extend([roll_mean, roll_std, roll_min, roll_max])</span>
<span id="cb25-58"><a href="#cb25-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-59"><a href="#cb25-59" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Z-score based on rolling statistics</span></span>
<span id="cb25-60"><a href="#cb25-60" aria-hidden="true" tabindex="-1"></a>                z_score <span class="op">=</span> (series.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>) <span class="op">-</span> roll_mean) <span class="op">/</span> (roll_std <span class="op">+</span> <span class="fl">1e-8</span>)</span>
<span id="cb25-61"><a href="#cb25-61" aria-hidden="true" tabindex="-1"></a>                features.append(z_score)</span>
<span id="cb25-62"><a href="#cb25-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-63"><a href="#cb25-63" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Differences and changes</span></span>
<span id="cb25-64"><a href="#cb25-64" aria-hidden="true" tabindex="-1"></a>                diff_from_mean <span class="op">=</span> series.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>) <span class="op">-</span> roll_mean</span>
<span id="cb25-65"><a href="#cb25-65" aria-hidden="true" tabindex="-1"></a>                features.append(diff_from_mean)</span>
<span id="cb25-66"><a href="#cb25-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-67"><a href="#cb25-67" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Global statistics</span></span>
<span id="cb25-68"><a href="#cb25-68" aria-hidden="true" tabindex="-1"></a>        global_mean <span class="op">=</span> np.full((<span class="bu">len</span>(series), <span class="dv">1</span>), np.mean(series))</span>
<span id="cb25-69"><a href="#cb25-69" aria-hidden="true" tabindex="-1"></a>        global_std <span class="op">=</span> np.full((<span class="bu">len</span>(series), <span class="dv">1</span>), np.std(series))</span>
<span id="cb25-70"><a href="#cb25-70" aria-hidden="true" tabindex="-1"></a>        global_z <span class="op">=</span> (series.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>) <span class="op">-</span> global_mean) <span class="op">/</span> (global_std <span class="op">+</span> <span class="fl">1e-8</span>)</span>
<span id="cb25-71"><a href="#cb25-71" aria-hidden="true" tabindex="-1"></a>        features.extend([global_mean, global_std, global_z])</span>
<span id="cb25-72"><a href="#cb25-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-73"><a href="#cb25-73" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Rate of change and derivatives</span></span>
<span id="cb25-74"><a href="#cb25-74" aria-hidden="true" tabindex="-1"></a>        diff_1 <span class="op">=</span> np.diff(series, prepend<span class="op">=</span>series[<span class="dv">0</span>])</span>
<span id="cb25-75"><a href="#cb25-75" aria-hidden="true" tabindex="-1"></a>        diff_2 <span class="op">=</span> np.diff(diff_1, prepend<span class="op">=</span>diff_1[<span class="dv">0</span>])</span>
<span id="cb25-76"><a href="#cb25-76" aria-hidden="true" tabindex="-1"></a>        features.extend([diff_1.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>), diff_2.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)])</span>
<span id="cb25-77"><a href="#cb25-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-78"><a href="#cb25-78" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Combine features</span></span>
<span id="cb25-79"><a href="#cb25-79" aria-hidden="true" tabindex="-1"></a>        feature_matrix <span class="op">=</span> np.hstack([f <span class="cf">for</span> f <span class="kw">in</span> features <span class="cf">if</span> f <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>])</span>
<span id="cb25-80"><a href="#cb25-80" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> feature_matrix</span>
<span id="cb25-81"><a href="#cb25-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-82"><a href="#cb25-82" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> find_anomaly_ranges_stricter(<span class="va">self</span>, predictions, max_gap<span class="op">=</span><span class="dv">5</span>, min_length<span class="op">=</span><span class="dv">3</span>):</span>
<span id="cb25-83"><a href="#cb25-83" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Stricter range grouping to reduce false positives"""</span></span>
<span id="cb25-84"><a href="#cb25-84" aria-hidden="true" tabindex="-1"></a>        anomaly_indices <span class="op">=</span> np.where(predictions <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>)[<span class="dv">0</span>]</span>
<span id="cb25-85"><a href="#cb25-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-86"><a href="#cb25-86" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(anomaly_indices) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb25-87"><a href="#cb25-87" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> []</span>
<span id="cb25-88"><a href="#cb25-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-89"><a href="#cb25-89" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Group anomalies with smaller allowed gaps</span></span>
<span id="cb25-90"><a href="#cb25-90" aria-hidden="true" tabindex="-1"></a>        ranges <span class="op">=</span> []</span>
<span id="cb25-91"><a href="#cb25-91" aria-hidden="true" tabindex="-1"></a>        start <span class="op">=</span> anomaly_indices[<span class="dv">0</span>]</span>
<span id="cb25-92"><a href="#cb25-92" aria-hidden="true" tabindex="-1"></a>        end <span class="op">=</span> anomaly_indices[<span class="dv">0</span>]</span>
<span id="cb25-93"><a href="#cb25-93" aria-hidden="true" tabindex="-1"></a>        consecutive_count <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb25-94"><a href="#cb25-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-95"><a href="#cb25-95" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(anomaly_indices)):</span>
<span id="cb25-96"><a href="#cb25-96" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> anomaly_indices[i] <span class="op">&lt;=</span> anomaly_indices[i<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> max_gap:  <span class="co"># Smaller gap</span></span>
<span id="cb25-97"><a href="#cb25-97" aria-hidden="true" tabindex="-1"></a>                end <span class="op">=</span> anomaly_indices[i]</span>
<span id="cb25-98"><a href="#cb25-98" aria-hidden="true" tabindex="-1"></a>                consecutive_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb25-99"><a href="#cb25-99" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb25-100"><a href="#cb25-100" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Only keep ranges with minimum length</span></span>
<span id="cb25-101"><a href="#cb25-101" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> consecutive_count <span class="op">&gt;=</span> min_length:  <span class="co"># Minimum length requirement</span></span>
<span id="cb25-102"><a href="#cb25-102" aria-hidden="true" tabindex="-1"></a>                    ranges.append((start, end))</span>
<span id="cb25-103"><a href="#cb25-103" aria-hidden="true" tabindex="-1"></a>                start <span class="op">=</span> anomaly_indices[i]</span>
<span id="cb25-104"><a href="#cb25-104" aria-hidden="true" tabindex="-1"></a>                end <span class="op">=</span> anomaly_indices[i]</span>
<span id="cb25-105"><a href="#cb25-105" aria-hidden="true" tabindex="-1"></a>                consecutive_count <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb25-106"><a href="#cb25-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-107"><a href="#cb25-107" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Only keep the last range if it meets minimum length</span></span>
<span id="cb25-108"><a href="#cb25-108" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> consecutive_count <span class="op">&gt;=</span> min_length:</span>
<span id="cb25-109"><a href="#cb25-109" aria-hidden="true" tabindex="-1"></a>            ranges.append((start, end))</span>
<span id="cb25-110"><a href="#cb25-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-111"><a href="#cb25-111" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ranges</span>
<span id="cb25-112"><a href="#cb25-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-113"><a href="#cb25-113" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> statistical_anomaly_detection(<span class="va">self</span>, series, z_threshold<span class="op">=</span><span class="fl">3.0</span>):  <span class="co"># KEEP: 3.0</span></span>
<span id="cb25-114"><a href="#cb25-114" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Statistical method using Z-scores with threshold = 3.0"""</span></span>
<span id="cb25-115"><a href="#cb25-115" aria-hidden="true" tabindex="-1"></a>        z_scores <span class="op">=</span> np.<span class="bu">abs</span>((series <span class="op">-</span> np.mean(series)) <span class="op">/</span> (np.std(series) <span class="op">+</span> <span class="fl">1e-8</span>))</span>
<span id="cb25-116"><a href="#cb25-116" aria-hidden="true" tabindex="-1"></a>        statistical_anomalies <span class="op">=</span> np.where(z_scores <span class="op">&gt;</span> z_threshold)[<span class="dv">0</span>]</span>
<span id="cb25-117"><a href="#cb25-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-118"><a href="#cb25-118" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Convert point anomalies to ranges with STRICTER grouping</span></span>
<span id="cb25-119"><a href="#cb25-119" aria-hidden="true" tabindex="-1"></a>        stat_ranges <span class="op">=</span> []</span>
<span id="cb25-120"><a href="#cb25-120" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(statistical_anomalies) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb25-121"><a href="#cb25-121" aria-hidden="true" tabindex="-1"></a>            start <span class="op">=</span> statistical_anomalies[<span class="dv">0</span>]</span>
<span id="cb25-122"><a href="#cb25-122" aria-hidden="true" tabindex="-1"></a>            end <span class="op">=</span> statistical_anomalies[<span class="dv">0</span>]</span>
<span id="cb25-123"><a href="#cb25-123" aria-hidden="true" tabindex="-1"></a>            consecutive_count <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb25-124"><a href="#cb25-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-125"><a href="#cb25-125" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(statistical_anomalies)):</span>
<span id="cb25-126"><a href="#cb25-126" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> statistical_anomalies[i] <span class="op">&lt;=</span> statistical_anomalies[i<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> <span class="dv">3</span>:  <span class="co"># STRICTER: 5 to 3</span></span>
<span id="cb25-127"><a href="#cb25-127" aria-hidden="true" tabindex="-1"></a>                    end <span class="op">=</span> statistical_anomalies[i]</span>
<span id="cb25-128"><a href="#cb25-128" aria-hidden="true" tabindex="-1"></a>                    consecutive_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb25-129"><a href="#cb25-129" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb25-130"><a href="#cb25-130" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># Only keep ranges with minimum length</span></span>
<span id="cb25-131"><a href="#cb25-131" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> consecutive_count <span class="op">&gt;=</span> <span class="dv">3</span>:  <span class="co"># Minimum 3 consecutive points</span></span>
<span id="cb25-132"><a href="#cb25-132" aria-hidden="true" tabindex="-1"></a>                        stat_ranges.append((start, end))</span>
<span id="cb25-133"><a href="#cb25-133" aria-hidden="true" tabindex="-1"></a>                    start <span class="op">=</span> statistical_anomalies[i]</span>
<span id="cb25-134"><a href="#cb25-134" aria-hidden="true" tabindex="-1"></a>                    end <span class="op">=</span> statistical_anomalies[i]</span>
<span id="cb25-135"><a href="#cb25-135" aria-hidden="true" tabindex="-1"></a>                    consecutive_count <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb25-136"><a href="#cb25-136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-137"><a href="#cb25-137" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> consecutive_count <span class="op">&gt;=</span> <span class="dv">3</span>:  <span class="co"># Minimum 3 consecutive points</span></span>
<span id="cb25-138"><a href="#cb25-138" aria-hidden="true" tabindex="-1"></a>                stat_ranges.append((start, end))</span>
<span id="cb25-139"><a href="#cb25-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-140"><a href="#cb25-140" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> stat_ranges</span>
<span id="cb25-141"><a href="#cb25-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-142"><a href="#cb25-142" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> optimize_contamination_for_precision(<span class="va">self</span>, X, target_precision<span class="op">=</span><span class="fl">0.7</span>):</span>
<span id="cb25-143"><a href="#cb25-143" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Optimize contamination parameter for better precision"""</span></span>
<span id="cb25-144"><a href="#cb25-144" aria-hidden="true" tabindex="-1"></a>        best_contamination <span class="op">=</span> <span class="va">self</span>.contamination_range[<span class="dv">0</span>]</span>
<span id="cb25-145"><a href="#cb25-145" aria-hidden="true" tabindex="-1"></a>        best_score <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb25-146"><a href="#cb25-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-147"><a href="#cb25-147" aria-hidden="true" tabindex="-1"></a>        contamination_values <span class="op">=</span> np.linspace(<span class="va">self</span>.contamination_range[<span class="dv">0</span>], <span class="va">self</span>.contamination_range[<span class="dv">1</span>], <span class="dv">20</span>)</span>
<span id="cb25-148"><a href="#cb25-148" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-149"><a href="#cb25-149" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> contamination <span class="kw">in</span> contamination_values:</span>
<span id="cb25-150"><a href="#cb25-150" aria-hidden="true" tabindex="-1"></a>            <span class="cf">try</span>:</span>
<span id="cb25-151"><a href="#cb25-151" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Create features</span></span>
<span id="cb25-152"><a href="#cb25-152" aria-hidden="true" tabindex="-1"></a>                X_features <span class="op">=</span> <span class="va">self</span>.create_enhanced_features(X)</span>
<span id="cb25-153"><a href="#cb25-153" aria-hidden="true" tabindex="-1"></a>                X_scaled <span class="op">=</span> <span class="va">self</span>.scaler.fit_transform(X_features)</span>
<span id="cb25-154"><a href="#cb25-154" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-155"><a href="#cb25-155" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Train Isolation Forest</span></span>
<span id="cb25-156"><a href="#cb25-156" aria-hidden="true" tabindex="-1"></a>                model <span class="op">=</span> IsolationForest(</span>
<span id="cb25-157"><a href="#cb25-157" aria-hidden="true" tabindex="-1"></a>                    contamination<span class="op">=</span>contamination,</span>
<span id="cb25-158"><a href="#cb25-158" aria-hidden="true" tabindex="-1"></a>                    random_state<span class="op">=</span><span class="va">self</span>.random_state,</span>
<span id="cb25-159"><a href="#cb25-159" aria-hidden="true" tabindex="-1"></a>                    n_estimators<span class="op">=</span><span class="dv">150</span>,  <span class="co"># More trees for stability</span></span>
<span id="cb25-160"><a href="#cb25-160" aria-hidden="true" tabindex="-1"></a>                    max_samples<span class="op">=</span><span class="dv">128</span>,   <span class="co"># Smaller samples for less overfitting</span></span>
<span id="cb25-161"><a href="#cb25-161" aria-hidden="true" tabindex="-1"></a>                    max_features<span class="op">=</span><span class="fl">0.7</span>,  <span class="co"># Use subset of features</span></span>
<span id="cb25-162"><a href="#cb25-162" aria-hidden="true" tabindex="-1"></a>                    n_jobs<span class="op">=-</span><span class="dv">1</span></span>
<span id="cb25-163"><a href="#cb25-163" aria-hidden="true" tabindex="-1"></a>                )</span>
<span id="cb25-164"><a href="#cb25-164" aria-hidden="true" tabindex="-1"></a>                model.fit(X_scaled)</span>
<span id="cb25-165"><a href="#cb25-165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-166"><a href="#cb25-166" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Predict anomalies</span></span>
<span id="cb25-167"><a href="#cb25-167" aria-hidden="true" tabindex="-1"></a>                predictions <span class="op">=</span> model.predict(X_scaled)</span>
<span id="cb25-168"><a href="#cb25-168" aria-hidden="true" tabindex="-1"></a>                pred_ranges <span class="op">=</span> <span class="va">self</span>.find_anomaly_ranges_stricter(predictions)</span>
<span id="cb25-169"><a href="#cb25-169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-170"><a href="#cb25-170" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Use anomaly count as precision proxy</span></span>
<span id="cb25-171"><a href="#cb25-171" aria-hidden="true" tabindex="-1"></a>                anomaly_ratio <span class="op">=</span> np.<span class="bu">sum</span>(predictions <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>) <span class="op">/</span> <span class="bu">len</span>(predictions)</span>
<span id="cb25-172"><a href="#cb25-172" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Lower anomaly ratio typically means higher precision</span></span>
<span id="cb25-173"><a href="#cb25-173" aria-hidden="true" tabindex="-1"></a>                precision_proxy <span class="op">=</span> <span class="fl">1.0</span> <span class="op">-</span> <span class="bu">min</span>(anomaly_ratio <span class="op">*</span> <span class="dv">3</span>, <span class="fl">0.9</span>)  <span class="co"># Favor lower contamination</span></span>
<span id="cb25-174"><a href="#cb25-174" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-175"><a href="#cb25-175" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> precision_proxy <span class="op">&gt;</span> best_score:</span>
<span id="cb25-176"><a href="#cb25-176" aria-hidden="true" tabindex="-1"></a>                    best_score <span class="op">=</span> precision_proxy</span>
<span id="cb25-177"><a href="#cb25-177" aria-hidden="true" tabindex="-1"></a>                    best_contamination <span class="op">=</span> contamination</span>
<span id="cb25-178"><a href="#cb25-178" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-179"><a href="#cb25-179" aria-hidden="true" tabindex="-1"></a>            <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb25-180"><a href="#cb25-180" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb25-181"><a href="#cb25-181" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-182"><a href="#cb25-182" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> best_contamination</span>
<span id="cb25-183"><a href="#cb25-183" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-184"><a href="#cb25-184" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> fit_predict(<span class="va">self</span>, X):</span>
<span id="cb25-185"><a href="#cb25-185" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Fit and predict with precision optimization"""</span></span>
<span id="cb25-186"><a href="#cb25-186" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb25-187"><a href="#cb25-187" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Optimize contamination for precision</span></span>
<span id="cb25-188"><a href="#cb25-188" aria-hidden="true" tabindex="-1"></a>            optimal_contamination <span class="op">=</span> <span class="va">self</span>.optimize_contamination_for_precision(X)</span>
<span id="cb25-189"><a href="#cb25-189" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Optimal contamination for precision: </span><span class="sc">{</span>optimal_contamination<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb25-190"><a href="#cb25-190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-191"><a href="#cb25-191" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Create enhanced features</span></span>
<span id="cb25-192"><a href="#cb25-192" aria-hidden="true" tabindex="-1"></a>            X_features <span class="op">=</span> <span class="va">self</span>.create_enhanced_features(X)</span>
<span id="cb25-193"><a href="#cb25-193" aria-hidden="true" tabindex="-1"></a>            X_scaled <span class="op">=</span> <span class="va">self</span>.scaler.fit_transform(X_features)</span>
<span id="cb25-194"><a href="#cb25-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-195"><a href="#cb25-195" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Train Isolation Forest with precision-optimized parameters</span></span>
<span id="cb25-196"><a href="#cb25-196" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.model <span class="op">=</span> IsolationForest(</span>
<span id="cb25-197"><a href="#cb25-197" aria-hidden="true" tabindex="-1"></a>                contamination<span class="op">=</span>optimal_contamination,</span>
<span id="cb25-198"><a href="#cb25-198" aria-hidden="true" tabindex="-1"></a>                random_state<span class="op">=</span><span class="va">self</span>.random_state,</span>
<span id="cb25-199"><a href="#cb25-199" aria-hidden="true" tabindex="-1"></a>                n_estimators<span class="op">=</span><span class="dv">150</span>,</span>
<span id="cb25-200"><a href="#cb25-200" aria-hidden="true" tabindex="-1"></a>                max_samples<span class="op">=</span><span class="dv">128</span>,  <span class="co"># Smaller for less overfitting</span></span>
<span id="cb25-201"><a href="#cb25-201" aria-hidden="true" tabindex="-1"></a>                max_features<span class="op">=</span><span class="fl">0.7</span>, <span class="co"># Use subset of features</span></span>
<span id="cb25-202"><a href="#cb25-202" aria-hidden="true" tabindex="-1"></a>                n_jobs<span class="op">=-</span><span class="dv">1</span></span>
<span id="cb25-203"><a href="#cb25-203" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb25-204"><a href="#cb25-204" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.model.fit(X_scaled)</span>
<span id="cb25-205"><a href="#cb25-205" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-206"><a href="#cb25-206" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Get Isolation Forest predictions with STRICTER range grouping</span></span>
<span id="cb25-207"><a href="#cb25-207" aria-hidden="true" tabindex="-1"></a>            iso_predictions <span class="op">=</span> <span class="va">self</span>.model.predict(X_scaled)</span>
<span id="cb25-208"><a href="#cb25-208" aria-hidden="true" tabindex="-1"></a>            iso_ranges <span class="op">=</span> <span class="va">self</span>.find_anomaly_ranges_stricter(iso_predictions, max_gap<span class="op">=</span><span class="dv">5</span>, min_length<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb25-209"><a href="#cb25-209" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-210"><a href="#cb25-210" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Get statistical method predictions with Z-threshold = 3.0</span></span>
<span id="cb25-211"><a href="#cb25-211" aria-hidden="true" tabindex="-1"></a>            stat_ranges <span class="op">=</span> <span class="va">self</span>.statistical_anomaly_detection(X, z_threshold<span class="op">=</span><span class="fl">3.0</span>)  <span class="co"># KEEP: 3.0</span></span>
<span id="cb25-212"><a href="#cb25-212" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-213"><a href="#cb25-213" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Combine methods but be more selective</span></span>
<span id="cb25-214"><a href="#cb25-214" aria-hidden="true" tabindex="-1"></a>            all_ranges <span class="op">=</span> []</span>
<span id="cb25-215"><a href="#cb25-215" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-216"><a href="#cb25-216" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Only add Isolation Forest ranges if they're substantial</span></span>
<span id="cb25-217"><a href="#cb25-217" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> start, end <span class="kw">in</span> iso_ranges:</span>
<span id="cb25-218"><a href="#cb25-218" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (end <span class="op">-</span> start) <span class="op">&gt;=</span> <span class="dv">2</span>:  <span class="co"># Minimum 3 points</span></span>
<span id="cb25-219"><a href="#cb25-219" aria-hidden="true" tabindex="-1"></a>                    all_ranges.append((start, end))</span>
<span id="cb25-220"><a href="#cb25-220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-221"><a href="#cb25-221" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Only add Z-score ranges if they're very clear</span></span>
<span id="cb25-222"><a href="#cb25-222" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> start, end <span class="kw">in</span> stat_ranges:</span>
<span id="cb25-223"><a href="#cb25-223" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (end <span class="op">-</span> start) <span class="op">&gt;=</span> <span class="dv">2</span>:  <span class="co"># Minimum 3 points for Z-score</span></span>
<span id="cb25-224"><a href="#cb25-224" aria-hidden="true" tabindex="-1"></a>                    all_ranges.append((start, end))</span>
<span id="cb25-225"><a href="#cb25-225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-226"><a href="#cb25-226" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Merge overlapping ranges with STRICTER criteria</span></span>
<span id="cb25-227"><a href="#cb25-227" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> all_ranges:</span>
<span id="cb25-228"><a href="#cb25-228" aria-hidden="true" tabindex="-1"></a>                all_ranges.sort()</span>
<span id="cb25-229"><a href="#cb25-229" aria-hidden="true" tabindex="-1"></a>                merged_ranges <span class="op">=</span> []</span>
<span id="cb25-230"><a href="#cb25-230" aria-hidden="true" tabindex="-1"></a>                current_start, current_end <span class="op">=</span> all_ranges[<span class="dv">0</span>]</span>
<span id="cb25-231"><a href="#cb25-231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-232"><a href="#cb25-232" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> start, end <span class="kw">in</span> all_ranges[<span class="dv">1</span>:]:</span>
<span id="cb25-233"><a href="#cb25-233" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> start <span class="op">&lt;=</span> current_end <span class="op">+</span> <span class="dv">10</span>:  <span class="co"># Smaller merge distance</span></span>
<span id="cb25-234"><a href="#cb25-234" aria-hidden="true" tabindex="-1"></a>                        current_end <span class="op">=</span> <span class="bu">max</span>(current_end, end)</span>
<span id="cb25-235"><a href="#cb25-235" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">else</span>:</span>
<span id="cb25-236"><a href="#cb25-236" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># Only keep merged range if substantial</span></span>
<span id="cb25-237"><a href="#cb25-237" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">if</span> (current_end <span class="op">-</span> current_start) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb25-238"><a href="#cb25-238" aria-hidden="true" tabindex="-1"></a>                            merged_ranges.append((current_start, current_end))</span>
<span id="cb25-239"><a href="#cb25-239" aria-hidden="true" tabindex="-1"></a>                        current_start, current_end <span class="op">=</span> start, end</span>
<span id="cb25-240"><a href="#cb25-240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-241"><a href="#cb25-241" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (current_end <span class="op">-</span> current_start) <span class="op">&gt;=</span> <span class="dv">2</span>:</span>
<span id="cb25-242"><a href="#cb25-242" aria-hidden="true" tabindex="-1"></a>                    merged_ranges.append((current_start, current_end))</span>
<span id="cb25-243"><a href="#cb25-243" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.anomaly_windows <span class="op">=</span> merged_ranges</span>
<span id="cb25-244"><a href="#cb25-244" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb25-245"><a href="#cb25-245" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.anomaly_windows <span class="op">=</span> []</span>
<span id="cb25-246"><a href="#cb25-246" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-247"><a href="#cb25-247" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Detected </span><span class="sc">{</span><span class="bu">len</span>(<span class="va">self</span>.anomaly_windows)<span class="sc">}</span><span class="ss"> high-confidence anomaly ranges"</span>)</span>
<span id="cb25-248"><a href="#cb25-248" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Isolation Forest ranges: </span><span class="sc">{</span><span class="bu">len</span>(iso_ranges)<span class="sc">}</span><span class="ss">, Z-score ranges: </span><span class="sc">{</span><span class="bu">len</span>(stat_ranges)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-249"><a href="#cb25-249" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">self</span>.anomaly_windows</span>
<span id="cb25-250"><a href="#cb25-250" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-251"><a href="#cb25-251" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb25-252"><a href="#cb25-252" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"Error in fit_predict: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-253"><a href="#cb25-253" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">self</span>.fallback_detection_precision(X)</span>
<span id="cb25-254"><a href="#cb25-254" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-255"><a href="#cb25-255" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> fallback_detection_precision(<span class="va">self</span>, X):</span>
<span id="cb25-256"><a href="#cb25-256" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Fallback with high precision settings"""</span></span>
<span id="cb25-257"><a href="#cb25-257" aria-hidden="true" tabindex="-1"></a>        <span class="im">from</span> sklearn.ensemble <span class="im">import</span> IsolationForest</span>
<span id="cb25-258"><a href="#cb25-258" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-259"><a href="#cb25-259" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Use lower contamination for higher precision</span></span>
<span id="cb25-260"><a href="#cb25-260" aria-hidden="true" tabindex="-1"></a>        model <span class="op">=</span> IsolationForest(</span>
<span id="cb25-261"><a href="#cb25-261" aria-hidden="true" tabindex="-1"></a>            contamination<span class="op">=</span><span class="fl">0.08</span>,  <span class="co"># Much lower</span></span>
<span id="cb25-262"><a href="#cb25-262" aria-hidden="true" tabindex="-1"></a>            random_state<span class="op">=</span><span class="va">self</span>.random_state,</span>
<span id="cb25-263"><a href="#cb25-263" aria-hidden="true" tabindex="-1"></a>            n_estimators<span class="op">=</span><span class="dv">100</span></span>
<span id="cb25-264"><a href="#cb25-264" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb25-265"><a href="#cb25-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-266"><a href="#cb25-266" aria-hidden="true" tabindex="-1"></a>        predictions <span class="op">=</span> model.fit_predict(X.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb25-267"><a href="#cb25-267" aria-hidden="true" tabindex="-1"></a>        anomaly_indices <span class="op">=</span> np.where(predictions <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>)[<span class="dv">0</span>]</span>
<span id="cb25-268"><a href="#cb25-268" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-269"><a href="#cb25-269" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Stricter range grouping</span></span>
<span id="cb25-270"><a href="#cb25-270" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(anomaly_indices) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb25-271"><a href="#cb25-271" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> []</span>
<span id="cb25-272"><a href="#cb25-272" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-273"><a href="#cb25-273" aria-hidden="true" tabindex="-1"></a>        ranges <span class="op">=</span> []</span>
<span id="cb25-274"><a href="#cb25-274" aria-hidden="true" tabindex="-1"></a>        start <span class="op">=</span> anomaly_indices[<span class="dv">0</span>]</span>
<span id="cb25-275"><a href="#cb25-275" aria-hidden="true" tabindex="-1"></a>        end <span class="op">=</span> anomaly_indices[<span class="dv">0</span>]</span>
<span id="cb25-276"><a href="#cb25-276" aria-hidden="true" tabindex="-1"></a>        consecutive_count <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb25-277"><a href="#cb25-277" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-278"><a href="#cb25-278" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(anomaly_indices)):</span>
<span id="cb25-279"><a href="#cb25-279" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> anomaly_indices[i] <span class="op">&lt;=</span> anomaly_indices[i<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> <span class="dv">5</span>:  <span class="co"># Stricter</span></span>
<span id="cb25-280"><a href="#cb25-280" aria-hidden="true" tabindex="-1"></a>                end <span class="op">=</span> anomaly_indices[i]</span>
<span id="cb25-281"><a href="#cb25-281" aria-hidden="true" tabindex="-1"></a>                consecutive_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb25-282"><a href="#cb25-282" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb25-283"><a href="#cb25-283" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> consecutive_count <span class="op">&gt;=</span> <span class="dv">3</span>:  <span class="co"># Minimum length</span></span>
<span id="cb25-284"><a href="#cb25-284" aria-hidden="true" tabindex="-1"></a>                    ranges.append((start, end))</span>
<span id="cb25-285"><a href="#cb25-285" aria-hidden="true" tabindex="-1"></a>                start <span class="op">=</span> anomaly_indices[i]</span>
<span id="cb25-286"><a href="#cb25-286" aria-hidden="true" tabindex="-1"></a>                end <span class="op">=</span> anomaly_indices[i]</span>
<span id="cb25-287"><a href="#cb25-287" aria-hidden="true" tabindex="-1"></a>                consecutive_count <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb25-288"><a href="#cb25-288" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-289"><a href="#cb25-289" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> consecutive_count <span class="op">&gt;=</span> <span class="dv">3</span>:</span>
<span id="cb25-290"><a href="#cb25-290" aria-hidden="true" tabindex="-1"></a>            ranges.append((start, end))</span>
<span id="cb25-291"><a href="#cb25-291" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-292"><a href="#cb25-292" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ranges</span>
<span id="cb25-293"><a href="#cb25-293" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-294"><a href="#cb25-294" aria-hidden="true" tabindex="-1"></a><span class="co"># Updated student detection function for higher precision (Z-score threshold = 3.0)</span></span>
<span id="cb25-295"><a href="#cb25-295" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> student_detect_anomalies(series: np.ndarray) <span class="op">-&gt;</span> <span class="bu">list</span>:</span>
<span id="cb25-296"><a href="#cb25-296" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb25-297"><a href="#cb25-297" aria-hidden="true" tabindex="-1"></a><span class="co">    High-precision version using stricter parameters with Z-score = 3.0</span></span>
<span id="cb25-298"><a href="#cb25-298" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb25-299"><a href="#cb25-299" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.asarray(series, dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb25-300"><a href="#cb25-300" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-301"><a href="#cb25-301" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(x) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb25-302"><a href="#cb25-302" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> []</span>
<span id="cb25-303"><a href="#cb25-303" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-304"><a href="#cb25-304" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb25-305"><a href="#cb25-305" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Use the high-precision detector</span></span>
<span id="cb25-306"><a href="#cb25-306" aria-hidden="true" tabindex="-1"></a>        detector <span class="op">=</span> HighPrecisionIsolationForestDetector(contamination_range<span class="op">=</span>(<span class="fl">0.05</span>, <span class="fl">0.2</span>))</span>
<span id="cb25-307"><a href="#cb25-307" aria-hidden="true" tabindex="-1"></a>        ranges <span class="op">=</span> detector.fit_predict(x)</span>
<span id="cb25-308"><a href="#cb25-308" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ranges</span>
<span id="cb25-309"><a href="#cb25-309" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb25-310"><a href="#cb25-310" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Error in student_detect_anomalies: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-311"><a href="#cb25-311" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> student_detect_anomalies_simple(series)</span>
<span id="cb25-312"><a href="#cb25-312" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-313"><a href="#cb25-313" aria-hidden="true" tabindex="-1"></a><span class="co"># Simple fallback function (keep as backup)</span></span>
<span id="cb25-314"><a href="#cb25-314" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> student_detect_anomalies_simple(series: np.ndarray) <span class="op">-&gt;</span> <span class="bu">list</span>:</span>
<span id="cb25-315"><a href="#cb25-315" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb25-316"><a href="#cb25-316" aria-hidden="true" tabindex="-1"></a><span class="co">    Simple improved version with just higher contamination</span></span>
<span id="cb25-317"><a href="#cb25-317" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb25-318"><a href="#cb25-318" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.asarray(series, dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb25-319"><a href="#cb25-319" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-320"><a href="#cb25-320" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(x) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb25-321"><a href="#cb25-321" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> []</span>
<span id="cb25-322"><a href="#cb25-322" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-323"><a href="#cb25-323" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Simple approach with significantly higher contamination</span></span>
<span id="cb25-324"><a href="#cb25-324" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> sklearn.ensemble <span class="im">import</span> IsolationForest</span>
<span id="cb25-325"><a href="#cb25-325" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-326"><a href="#cb25-326" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Use much higher contamination</span></span>
<span id="cb25-327"><a href="#cb25-327" aria-hidden="true" tabindex="-1"></a>    iso_forest <span class="op">=</span> IsolationForest(</span>
<span id="cb25-328"><a href="#cb25-328" aria-hidden="true" tabindex="-1"></a>        contamination<span class="op">=</span><span class="fl">0.2</span>,</span>
<span id="cb25-329"><a href="#cb25-329" aria-hidden="true" tabindex="-1"></a>        random_state<span class="op">=</span><span class="dv">42</span>,</span>
<span id="cb25-330"><a href="#cb25-330" aria-hidden="true" tabindex="-1"></a>        n_estimators<span class="op">=</span><span class="dv">100</span></span>
<span id="cb25-331"><a href="#cb25-331" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb25-332"><a href="#cb25-332" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-333"><a href="#cb25-333" aria-hidden="true" tabindex="-1"></a>    predictions <span class="op">=</span> iso_forest.fit_predict(x.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb25-334"><a href="#cb25-334" aria-hidden="true" tabindex="-1"></a>    anomaly_indices <span class="op">=</span> np.where(predictions <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>)[<span class="dv">0</span>]</span>
<span id="cb25-335"><a href="#cb25-335" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-336"><a href="#cb25-336" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Lenient range grouping with allowed gaps</span></span>
<span id="cb25-337"><a href="#cb25-337" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(anomaly_indices) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb25-338"><a href="#cb25-338" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> []</span>
<span id="cb25-339"><a href="#cb25-339" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-340"><a href="#cb25-340" aria-hidden="true" tabindex="-1"></a>    ranges <span class="op">=</span> []</span>
<span id="cb25-341"><a href="#cb25-341" aria-hidden="true" tabindex="-1"></a>    start <span class="op">=</span> anomaly_indices[<span class="dv">0</span>]</span>
<span id="cb25-342"><a href="#cb25-342" aria-hidden="true" tabindex="-1"></a>    end <span class="op">=</span> anomaly_indices[<span class="dv">0</span>]</span>
<span id="cb25-343"><a href="#cb25-343" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-344"><a href="#cb25-344" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(anomaly_indices)):</span>
<span id="cb25-345"><a href="#cb25-345" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> anomaly_indices[i] <span class="op">&lt;=</span> anomaly_indices[i<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> <span class="dv">10</span>:</span>
<span id="cb25-346"><a href="#cb25-346" aria-hidden="true" tabindex="-1"></a>            end <span class="op">=</span> anomaly_indices[i]</span>
<span id="cb25-347"><a href="#cb25-347" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb25-348"><a href="#cb25-348" aria-hidden="true" tabindex="-1"></a>            ranges.append((start, end))</span>
<span id="cb25-349"><a href="#cb25-349" aria-hidden="true" tabindex="-1"></a>            start <span class="op">=</span> anomaly_indices[i]</span>
<span id="cb25-350"><a href="#cb25-350" aria-hidden="true" tabindex="-1"></a>            end <span class="op">=</span> anomaly_indices[i]</span>
<span id="cb25-351"><a href="#cb25-351" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-352"><a href="#cb25-352" aria-hidden="true" tabindex="-1"></a>    ranges.append((start, end))</span>
<span id="cb25-353"><a href="#cb25-353" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ranges</span>
<span id="cb25-354"><a href="#cb25-354" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-355"><a href="#cb25-355" aria-hidden="true" tabindex="-1"></a><span class="co"># Keep the same evaluation function and main loop as before</span></span>
<span id="cb25-356"><a href="#cb25-356" aria-hidden="true" tabindex="-1"></a><span class="co"># Enhanced evaluation function with detailed range information</span></span>
<span id="cb25-357"><a href="#cb25-357" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evaluate_anomaly_detection_formatted(true_ranges, predicted_ranges, tolerance<span class="op">=</span><span class="dv">5</span>, file_idx<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb25-358"><a href="#cb25-358" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb25-359"><a href="#cb25-359" aria-hidden="true" tabindex="-1"></a><span class="co">    Evaluate anomaly detection performance with exact formatting as requested</span></span>
<span id="cb25-360"><a href="#cb25-360" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb25-361"><a href="#cb25-361" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert point-level predictions</span></span>
<span id="cb25-362"><a href="#cb25-362" aria-hidden="true" tabindex="-1"></a>    series_length <span class="op">=</span> <span class="bu">max</span>(</span>
<span id="cb25-363"><a href="#cb25-363" aria-hidden="true" tabindex="-1"></a>        <span class="bu">max</span>([end <span class="cf">for</span> _, end <span class="kw">in</span> true_ranges]) <span class="cf">if</span> true_ranges <span class="cf">else</span> <span class="dv">0</span>,</span>
<span id="cb25-364"><a href="#cb25-364" aria-hidden="true" tabindex="-1"></a>        <span class="bu">max</span>([end <span class="cf">for</span> _, end <span class="kw">in</span> predicted_ranges]) <span class="cf">if</span> predicted_ranges <span class="cf">else</span> <span class="dv">0</span>,</span>
<span id="cb25-365"><a href="#cb25-365" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0</span></span>
<span id="cb25-366"><a href="#cb25-366" aria-hidden="true" tabindex="-1"></a>    ) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb25-367"><a href="#cb25-367" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-368"><a href="#cb25-368" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create point-level arrays</span></span>
<span id="cb25-369"><a href="#cb25-369" aria-hidden="true" tabindex="-1"></a>    true_point_labels <span class="op">=</span> np.zeros(series_length, dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb25-370"><a href="#cb25-370" aria-hidden="true" tabindex="-1"></a>    pred_point_labels <span class="op">=</span> np.zeros(series_length, dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb25-371"><a href="#cb25-371" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-372"><a href="#cb25-372" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Mark true anomalies</span></span>
<span id="cb25-373"><a href="#cb25-373" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> start, end <span class="kw">in</span> true_ranges:</span>
<span id="cb25-374"><a href="#cb25-374" aria-hidden="true" tabindex="-1"></a>        true_point_labels[start:end<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb25-375"><a href="#cb25-375" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-376"><a href="#cb25-376" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Mark predicted anomalies</span></span>
<span id="cb25-377"><a href="#cb25-377" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> start, end <span class="kw">in</span> predicted_ranges:</span>
<span id="cb25-378"><a href="#cb25-378" aria-hidden="true" tabindex="-1"></a>        pred_point_labels[start:end<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb25-379"><a href="#cb25-379" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-380"><a href="#cb25-380" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate point-level metrics</span></span>
<span id="cb25-381"><a href="#cb25-381" aria-hidden="true" tabindex="-1"></a>    true_positives <span class="op">=</span> np.<span class="bu">sum</span>((true_point_labels <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (pred_point_labels <span class="op">==</span> <span class="dv">1</span>))</span>
<span id="cb25-382"><a href="#cb25-382" aria-hidden="true" tabindex="-1"></a>    false_positives <span class="op">=</span> np.<span class="bu">sum</span>((true_point_labels <span class="op">==</span> <span class="dv">0</span>) <span class="op">&amp;</span> (pred_point_labels <span class="op">==</span> <span class="dv">1</span>))</span>
<span id="cb25-383"><a href="#cb25-383" aria-hidden="true" tabindex="-1"></a>    false_negatives <span class="op">=</span> np.<span class="bu">sum</span>((true_point_labels <span class="op">==</span> <span class="dv">1</span>) <span class="op">&amp;</span> (pred_point_labels <span class="op">==</span> <span class="dv">0</span>))</span>
<span id="cb25-384"><a href="#cb25-384" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-385"><a href="#cb25-385" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Basic metrics</span></span>
<span id="cb25-386"><a href="#cb25-386" aria-hidden="true" tabindex="-1"></a>    accuracy <span class="op">=</span> (true_positives <span class="op">+</span> (series_length <span class="op">-</span> true_positives <span class="op">-</span> false_positives <span class="op">-</span> false_negatives)) <span class="op">/</span> series_length</span>
<span id="cb25-387"><a href="#cb25-387" aria-hidden="true" tabindex="-1"></a>    precision <span class="op">=</span> true_positives <span class="op">/</span> (true_positives <span class="op">+</span> false_positives) <span class="cf">if</span> (true_positives <span class="op">+</span> false_positives) <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb25-388"><a href="#cb25-388" aria-hidden="true" tabindex="-1"></a>    recall <span class="op">=</span> true_positives <span class="op">/</span> (true_positives <span class="op">+</span> false_negatives) <span class="cf">if</span> (true_positives <span class="op">+</span> false_negatives) <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb25-389"><a href="#cb25-389" aria-hidden="true" tabindex="-1"></a>    f1 <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> (precision <span class="op">*</span> recall) <span class="op">/</span> (precision <span class="op">+</span> recall) <span class="cf">if</span> (precision <span class="op">+</span> recall) <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb25-390"><a href="#cb25-390" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-391"><a href="#cb25-391" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Range-based metrics</span></span>
<span id="cb25-392"><a href="#cb25-392" aria-hidden="true" tabindex="-1"></a>    range_true_positives <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb25-393"><a href="#cb25-393" aria-hidden="true" tabindex="-1"></a>    range_false_positives <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb25-394"><a href="#cb25-394" aria-hidden="true" tabindex="-1"></a>    range_false_negatives <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb25-395"><a href="#cb25-395" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-396"><a href="#cb25-396" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check each predicted range against true ranges</span></span>
<span id="cb25-397"><a href="#cb25-397" aria-hidden="true" tabindex="-1"></a>    matched_true_ranges <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb25-398"><a href="#cb25-398" aria-hidden="true" tabindex="-1"></a>    matched_pairs <span class="op">=</span> []</span>
<span id="cb25-399"><a href="#cb25-399" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-400"><a href="#cb25-400" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> pred_start, pred_end <span class="kw">in</span> predicted_ranges:</span>
<span id="cb25-401"><a href="#cb25-401" aria-hidden="true" tabindex="-1"></a>        matched <span class="op">=</span> <span class="va">False</span></span>
<span id="cb25-402"><a href="#cb25-402" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, (true_start, true_end) <span class="kw">in</span> <span class="bu">enumerate</span>(true_ranges):</span>
<span id="cb25-403"><a href="#cb25-403" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Check if predicted range overlaps with true range within tolerance</span></span>
<span id="cb25-404"><a href="#cb25-404" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (pred_start <span class="op">&lt;=</span> true_end <span class="op">+</span> tolerance <span class="kw">and</span> pred_end <span class="op">&gt;=</span> true_start <span class="op">-</span> tolerance):</span>
<span id="cb25-405"><a href="#cb25-405" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> i <span class="kw">not</span> <span class="kw">in</span> matched_true_ranges:</span>
<span id="cb25-406"><a href="#cb25-406" aria-hidden="true" tabindex="-1"></a>                    range_true_positives <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb25-407"><a href="#cb25-407" aria-hidden="true" tabindex="-1"></a>                    matched_true_ranges.add(i)</span>
<span id="cb25-408"><a href="#cb25-408" aria-hidden="true" tabindex="-1"></a>                    matched_pairs.append((i, (pred_start, pred_end), (true_start, true_end)))</span>
<span id="cb25-409"><a href="#cb25-409" aria-hidden="true" tabindex="-1"></a>                    matched <span class="op">=</span> <span class="va">True</span></span>
<span id="cb25-410"><a href="#cb25-410" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">break</span></span>
<span id="cb25-411"><a href="#cb25-411" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-412"><a href="#cb25-412" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> matched:</span>
<span id="cb25-413"><a href="#cb25-413" aria-hidden="true" tabindex="-1"></a>            range_false_positives <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb25-414"><a href="#cb25-414" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-415"><a href="#cb25-415" aria-hidden="true" tabindex="-1"></a>    range_false_negatives <span class="op">=</span> <span class="bu">len</span>(true_ranges) <span class="op">-</span> <span class="bu">len</span>(matched_true_ranges)</span>
<span id="cb25-416"><a href="#cb25-416" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-417"><a href="#cb25-417" aria-hidden="true" tabindex="-1"></a>    range_precision <span class="op">=</span> range_true_positives <span class="op">/</span> (range_true_positives <span class="op">+</span> range_false_positives) <span class="cf">if</span> (range_true_positives <span class="op">+</span> range_false_positives) <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb25-418"><a href="#cb25-418" aria-hidden="true" tabindex="-1"></a>    range_recall <span class="op">=</span> range_true_positives <span class="op">/</span> <span class="bu">len</span>(true_ranges) <span class="cf">if</span> <span class="bu">len</span>(true_ranges) <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb25-419"><a href="#cb25-419" aria-hidden="true" tabindex="-1"></a>    range_f1 <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> (range_precision <span class="op">*</span> range_recall) <span class="op">/</span> (range_precision <span class="op">+</span> range_recall) <span class="cf">if</span> (range_precision <span class="op">+</span> range_recall) <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb25-420"><a href="#cb25-420" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-421"><a href="#cb25-421" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Segment detection metrics</span></span>
<span id="cb25-422"><a href="#cb25-422" aria-hidden="true" tabindex="-1"></a>    fully_detected <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb25-423"><a href="#cb25-423" aria-hidden="true" tabindex="-1"></a>    partially_detected <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb25-424"><a href="#cb25-424" aria-hidden="true" tabindex="-1"></a>    missed <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb25-425"><a href="#cb25-425" aria-hidden="true" tabindex="-1"></a>    detection_details <span class="op">=</span> []</span>
<span id="cb25-426"><a href="#cb25-426" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-427"><a href="#cb25-427" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, (true_start, true_end) <span class="kw">in</span> <span class="bu">enumerate</span>(true_ranges):</span>
<span id="cb25-428"><a href="#cb25-428" aria-hidden="true" tabindex="-1"></a>        detected_points <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb25-429"><a href="#cb25-429" aria-hidden="true" tabindex="-1"></a>        overlapping_ranges <span class="op">=</span> []</span>
<span id="cb25-430"><a href="#cb25-430" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-431"><a href="#cb25-431" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> pred_start, pred_end <span class="kw">in</span> predicted_ranges:</span>
<span id="cb25-432"><a href="#cb25-432" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Calculate overlap</span></span>
<span id="cb25-433"><a href="#cb25-433" aria-hidden="true" tabindex="-1"></a>            overlap_start <span class="op">=</span> <span class="bu">max</span>(true_start, pred_start)</span>
<span id="cb25-434"><a href="#cb25-434" aria-hidden="true" tabindex="-1"></a>            overlap_end <span class="op">=</span> <span class="bu">min</span>(true_end, pred_end)</span>
<span id="cb25-435"><a href="#cb25-435" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> overlap_start <span class="op">&lt;=</span> overlap_end:</span>
<span id="cb25-436"><a href="#cb25-436" aria-hidden="true" tabindex="-1"></a>                overlap_points <span class="op">=</span> overlap_end <span class="op">-</span> overlap_start <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb25-437"><a href="#cb25-437" aria-hidden="true" tabindex="-1"></a>                detected_points <span class="op">+=</span> overlap_points</span>
<span id="cb25-438"><a href="#cb25-438" aria-hidden="true" tabindex="-1"></a>                overlapping_ranges.append((pred_start, pred_end, overlap_points))</span>
<span id="cb25-439"><a href="#cb25-439" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-440"><a href="#cb25-440" aria-hidden="true" tabindex="-1"></a>        total_points <span class="op">=</span> true_end <span class="op">-</span> true_start <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb25-441"><a href="#cb25-441" aria-hidden="true" tabindex="-1"></a>        detection_ratio <span class="op">=</span> detected_points <span class="op">/</span> total_points <span class="cf">if</span> total_points <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb25-442"><a href="#cb25-442" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-443"><a href="#cb25-443" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> detection_ratio <span class="op">&gt;=</span> <span class="fl">0.8</span>:  <span class="co"># 80% threshold for full detection</span></span>
<span id="cb25-444"><a href="#cb25-444" aria-hidden="true" tabindex="-1"></a>            fully_detected <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb25-445"><a href="#cb25-445" aria-hidden="true" tabindex="-1"></a>            detection_status <span class="op">=</span> <span class="st">"FULL"</span></span>
<span id="cb25-446"><a href="#cb25-446" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> detection_ratio <span class="op">&gt;</span> <span class="dv">0</span>:   <span class="co"># Any detection counts as partial</span></span>
<span id="cb25-447"><a href="#cb25-447" aria-hidden="true" tabindex="-1"></a>            partially_detected <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb25-448"><a href="#cb25-448" aria-hidden="true" tabindex="-1"></a>            detection_status <span class="op">=</span> <span class="st">"PARTIAL"</span></span>
<span id="cb25-449"><a href="#cb25-449" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb25-450"><a href="#cb25-450" aria-hidden="true" tabindex="-1"></a>            missed <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb25-451"><a href="#cb25-451" aria-hidden="true" tabindex="-1"></a>            detection_status <span class="op">=</span> <span class="st">"MISSED"</span></span>
<span id="cb25-452"><a href="#cb25-452" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-453"><a href="#cb25-453" aria-hidden="true" tabindex="-1"></a>        detection_details.append({</span>
<span id="cb25-454"><a href="#cb25-454" aria-hidden="true" tabindex="-1"></a>            <span class="st">'true_range'</span>: (true_start, true_end),</span>
<span id="cb25-455"><a href="#cb25-455" aria-hidden="true" tabindex="-1"></a>            <span class="st">'detection_ratio'</span>: detection_ratio,</span>
<span id="cb25-456"><a href="#cb25-456" aria-hidden="true" tabindex="-1"></a>            <span class="st">'status'</span>: detection_status,</span>
<span id="cb25-457"><a href="#cb25-457" aria-hidden="true" tabindex="-1"></a>            <span class="st">'overlapping_ranges'</span>: overlapping_ranges,</span>
<span id="cb25-458"><a href="#cb25-458" aria-hidden="true" tabindex="-1"></a>            <span class="st">'detected_points'</span>: detected_points,</span>
<span id="cb25-459"><a href="#cb25-459" aria-hidden="true" tabindex="-1"></a>            <span class="st">'total_points'</span>: total_points</span>
<span id="cb25-460"><a href="#cb25-460" aria-hidden="true" tabindex="-1"></a>        })</span>
<span id="cb25-461"><a href="#cb25-461" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-462"><a href="#cb25-462" aria-hidden="true" tabindex="-1"></a>    segment_detection_rate <span class="op">=</span> fully_detected <span class="op">/</span> <span class="bu">len</span>(true_ranges) <span class="cf">if</span> <span class="bu">len</span>(true_ranges) <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb25-463"><a href="#cb25-463" aria-hidden="true" tabindex="-1"></a>    overall_detection_rate <span class="op">=</span> (fully_detected <span class="op">+</span> partially_detected) <span class="op">/</span> <span class="bu">len</span>(true_ranges) <span class="cf">if</span> <span class="bu">len</span>(true_ranges) <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb25-464"><a href="#cb25-464" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-465"><a href="#cb25-465" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Print results in the exact format requested</span></span>
<span id="cb25-466"><a href="#cb25-466" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"EVALUATION RESULTS - FILE </span><span class="sc">{</span>file_idx<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-467"><a href="#cb25-467" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"="</span> <span class="op">*</span> <span class="dv">60</span>)</span>
<span id="cb25-468"><a href="#cb25-468" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-469"><a href="#cb25-469" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Display range information</span></span>
<span id="cb25-470"><a href="#cb25-470" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Range Information:"</span>)</span>
<span id="cb25-471"><a href="#cb25-471" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  True Ranges: </span><span class="sc">{</span>true_ranges<span class="sc">}</span><span class="ss"> (count: </span><span class="sc">{</span><span class="bu">len</span>(true_ranges)<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb25-472"><a href="#cb25-472" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Predicted Ranges: </span><span class="sc">{</span>predicted_ranges<span class="sc">}</span><span class="ss"> (count: </span><span class="sc">{</span><span class="bu">len</span>(predicted_ranges)<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb25-473"><a href="#cb25-473" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>()</span>
<span id="cb25-474"><a href="#cb25-474" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-475"><a href="#cb25-475" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Display detection details for each true range</span></span>
<span id="cb25-476"><a href="#cb25-476" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> detection_details:</span>
<span id="cb25-477"><a href="#cb25-477" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"Detection Details by Segment:"</span>)</span>
<span id="cb25-478"><a href="#cb25-478" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, detail <span class="kw">in</span> <span class="bu">enumerate</span>(detection_details):</span>
<span id="cb25-479"><a href="#cb25-479" aria-hidden="true" tabindex="-1"></a>            status_symbol <span class="op">=</span> <span class="st">"✓"</span> <span class="cf">if</span> detail[<span class="st">'status'</span>] <span class="op">==</span> <span class="st">"FULL"</span> <span class="cf">else</span> <span class="st">"~"</span> <span class="cf">if</span> detail[<span class="st">'status'</span>] <span class="op">==</span> <span class="st">"PARTIAL"</span> <span class="cf">else</span> <span class="st">"✗"</span></span>
<span id="cb25-480"><a href="#cb25-480" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"  Segment </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>detail[<span class="st">'true_range'</span>]<span class="sc">}</span><span class="ss"> </span><span class="sc">{</span>status_symbol<span class="sc">}</span><span class="ss"> </span><span class="sc">{</span>detail[<span class="st">'status'</span>]<span class="sc">}</span><span class="ss"> "</span></span>
<span id="cb25-481"><a href="#cb25-481" aria-hidden="true" tabindex="-1"></a>                  <span class="ss">f"(</span><span class="sc">{</span>detail[<span class="st">'detected_points'</span>]<span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>detail[<span class="st">'total_points'</span>]<span class="sc">}</span><span class="ss"> points, "</span></span>
<span id="cb25-482"><a href="#cb25-482" aria-hidden="true" tabindex="-1"></a>                  <span class="ss">f"</span><span class="sc">{</span>detail[<span class="st">'detection_ratio'</span>]<span class="sc">:.1%}</span><span class="ss">)"</span>)</span>
<span id="cb25-483"><a href="#cb25-483" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> detail[<span class="st">'overlapping_ranges'</span>]:</span>
<span id="cb25-484"><a href="#cb25-484" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> pred_range <span class="kw">in</span> detail[<span class="st">'overlapping_ranges'</span>]:</span>
<span id="cb25-485"><a href="#cb25-485" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">print</span>(<span class="ss">f"    → Overlap with predicted range </span><span class="sc">{</span>pred_range[<span class="dv">0</span>:<span class="dv">2</span>]<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>pred_range[<span class="dv">2</span>]<span class="sc">}</span><span class="ss"> points"</span>)</span>
<span id="cb25-486"><a href="#cb25-486" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>()</span>
<span id="cb25-487"><a href="#cb25-487" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-488"><a href="#cb25-488" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Basic Metrics:"</span>)</span>
<span id="cb25-489"><a href="#cb25-489" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Accuracy:  </span><span class="sc">{</span>accuracy<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb25-490"><a href="#cb25-490" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Precision: </span><span class="sc">{</span>precision<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb25-491"><a href="#cb25-491" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Recall:    </span><span class="sc">{</span>recall<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb25-492"><a href="#cb25-492" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  F1-Score:  </span><span class="sc">{</span>f1<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb25-493"><a href="#cb25-493" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>()</span>
<span id="cb25-494"><a href="#cb25-494" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Anomaly Statistics:"</span>)</span>
<span id="cb25-495"><a href="#cb25-495" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  True Anomalies: </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">sum</span>(true_point_labels)<span class="sc">}</span><span class="ss"> points"</span>)</span>
<span id="cb25-496"><a href="#cb25-496" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Predicted Anomalies: </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">sum</span>(pred_point_labels)<span class="sc">}</span><span class="ss"> points"</span>)</span>
<span id="cb25-497"><a href="#cb25-497" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Detection Rate: </span><span class="sc">{</span>recall<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb25-498"><a href="#cb25-498" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>()</span>
<span id="cb25-499"><a href="#cb25-499" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Range-based Metrics:"</span>)</span>
<span id="cb25-500"><a href="#cb25-500" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Range Precision: </span><span class="sc">{</span>range_precision<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb25-501"><a href="#cb25-501" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Range Recall:    </span><span class="sc">{</span>range_recall<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb25-502"><a href="#cb25-502" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Range F1:        </span><span class="sc">{</span>range_f1<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb25-503"><a href="#cb25-503" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>()</span>
<span id="cb25-504"><a href="#cb25-504" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Point-level Performance:"</span>)</span>
<span id="cb25-505"><a href="#cb25-505" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  True Positives:  </span><span class="sc">{</span>true_positives<span class="sc">}</span><span class="ss"> points"</span>)</span>
<span id="cb25-506"><a href="#cb25-506" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  False Positives: </span><span class="sc">{</span>false_positives<span class="sc">}</span><span class="ss"> points"</span>)</span>
<span id="cb25-507"><a href="#cb25-507" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  False Negatives: </span><span class="sc">{</span>false_negatives<span class="sc">}</span><span class="ss"> points"</span>)</span>
<span id="cb25-508"><a href="#cb25-508" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>()</span>
<span id="cb25-509"><a href="#cb25-509" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Segment Detection Metrics:"</span>)</span>
<span id="cb25-510"><a href="#cb25-510" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Total Anomaly Segments: </span><span class="sc">{</span><span class="bu">len</span>(true_ranges)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-511"><a href="#cb25-511" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Fully Detected: </span><span class="sc">{</span>fully_detected<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-512"><a href="#cb25-512" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Partially Detected: </span><span class="sc">{</span>partially_detected<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-513"><a href="#cb25-513" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Missed: </span><span class="sc">{</span>missed<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-514"><a href="#cb25-514" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Segment Detection Rate: </span><span class="sc">{</span>segment_detection_rate<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb25-515"><a href="#cb25-515" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  Overall Detection Rate: </span><span class="sc">{</span>overall_detection_rate<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb25-516"><a href="#cb25-516" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>()</span>
<span id="cb25-517"><a href="#cb25-517" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-518"><a href="#cb25-518" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> {</span>
<span id="cb25-519"><a href="#cb25-519" aria-hidden="true" tabindex="-1"></a>        <span class="st">'accuracy'</span>: accuracy,</span>
<span id="cb25-520"><a href="#cb25-520" aria-hidden="true" tabindex="-1"></a>        <span class="st">'precision'</span>: precision,</span>
<span id="cb25-521"><a href="#cb25-521" aria-hidden="true" tabindex="-1"></a>        <span class="st">'recall'</span>: recall,</span>
<span id="cb25-522"><a href="#cb25-522" aria-hidden="true" tabindex="-1"></a>        <span class="st">'f1_score'</span>: f1,</span>
<span id="cb25-523"><a href="#cb25-523" aria-hidden="true" tabindex="-1"></a>        <span class="st">'true_positives'</span>: true_positives,</span>
<span id="cb25-524"><a href="#cb25-524" aria-hidden="true" tabindex="-1"></a>        <span class="st">'false_positives'</span>: false_positives,</span>
<span id="cb25-525"><a href="#cb25-525" aria-hidden="true" tabindex="-1"></a>        <span class="st">'false_negatives'</span>: false_negatives,</span>
<span id="cb25-526"><a href="#cb25-526" aria-hidden="true" tabindex="-1"></a>        <span class="st">'range_precision'</span>: range_precision,</span>
<span id="cb25-527"><a href="#cb25-527" aria-hidden="true" tabindex="-1"></a>        <span class="st">'range_recall'</span>: range_recall,</span>
<span id="cb25-528"><a href="#cb25-528" aria-hidden="true" tabindex="-1"></a>        <span class="st">'range_f1'</span>: range_f1,</span>
<span id="cb25-529"><a href="#cb25-529" aria-hidden="true" tabindex="-1"></a>        <span class="st">'fully_detected'</span>: fully_detected,</span>
<span id="cb25-530"><a href="#cb25-530" aria-hidden="true" tabindex="-1"></a>        <span class="st">'partially_detected'</span>: partially_detected,</span>
<span id="cb25-531"><a href="#cb25-531" aria-hidden="true" tabindex="-1"></a>        <span class="st">'missed'</span>: missed,</span>
<span id="cb25-532"><a href="#cb25-532" aria-hidden="true" tabindex="-1"></a>        <span class="st">'segment_detection_rate'</span>: segment_detection_rate,</span>
<span id="cb25-533"><a href="#cb25-533" aria-hidden="true" tabindex="-1"></a>        <span class="st">'overall_detection_rate'</span>: overall_detection_rate,</span>
<span id="cb25-534"><a href="#cb25-534" aria-hidden="true" tabindex="-1"></a>        <span class="st">'true_ranges'</span>: true_ranges,</span>
<span id="cb25-535"><a href="#cb25-535" aria-hidden="true" tabindex="-1"></a>        <span class="st">'predicted_ranges'</span>: predicted_ranges,</span>
<span id="cb25-536"><a href="#cb25-536" aria-hidden="true" tabindex="-1"></a>        <span class="st">'detection_details'</span>: detection_details,</span>
<span id="cb25-537"><a href="#cb25-537" aria-hidden="true" tabindex="-1"></a>        <span class="st">'matched_pairs'</span>: matched_pairs</span>
<span id="cb25-538"><a href="#cb25-538" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb25-539"><a href="#cb25-539" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-540"><a href="#cb25-540" aria-hidden="true" tabindex="-1"></a><span class="co"># Updated main evaluation loop with high-precision settings (Z-score threshold = 3.0)</span></span>
<span id="cb25-541"><a href="#cb25-541" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Starting HIGH-PRECISION Anomaly Detection Evaluation"</span>)</span>
<span id="cb25-542"><a href="#cb25-542" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Key improvements for higher precision:"</span>)</span>
<span id="cb25-543"><a href="#cb25-543" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"- Contamination range: 0.05-0.2 (reduced from 0.1-0.4)"</span>)</span>
<span id="cb25-544"><a href="#cb25-544" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"- Z-score threshold: 3.0 (maintained)"</span>)</span>
<span id="cb25-545"><a href="#cb25-545" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"- Stricter range grouping (max_gap=5, min_length=3)"</span>)</span>
<span id="cb25-546"><a href="#cb25-546" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"- Anti-overfitting measures (more trees, smaller samples)"</span>)</span>
<span id="cb25-547"><a href="#cb25-547" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"- More selective range merging and combination"</span>)</span>
<span id="cb25-548"><a href="#cb25-548" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"="</span> <span class="op">*</span> <span class="dv">80</span>)</span>
<span id="cb25-549"><a href="#cb25-549" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-550"><a href="#cb25-550" aria-hidden="true" tabindex="-1"></a>total_files <span class="op">=</span> <span class="bu">len</span>(test_files)</span>
<span id="cb25-551"><a href="#cb25-551" aria-hidden="true" tabindex="-1"></a>all_metrics <span class="op">=</span> []</span>
<span id="cb25-552"><a href="#cb25-552" aria-hidden="true" tabindex="-1"></a>detailed_results <span class="op">=</span> []</span>
<span id="cb25-553"><a href="#cb25-553" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-554"><a href="#cb25-554" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> idx, test_df <span class="kw">in</span> <span class="bu">enumerate</span>(test_files):</span>
<span id="cb25-555"><a href="#cb25-555" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="sc">{</span><span class="st">'='</span><span class="op">*</span><span class="dv">80</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-556"><a href="#cb25-556" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-557"><a href="#cb25-557" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb25-558"><a href="#cb25-558" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Extract series and labels</span></span>
<span id="cb25-559"><a href="#cb25-559" aria-hidden="true" tabindex="-1"></a>        series <span class="op">=</span> test_df[<span class="st">'Value'</span>].values <span class="cf">if</span> <span class="st">'Value'</span> <span class="kw">in</span> test_df.columns <span class="cf">else</span> test_df.iloc[:, <span class="dv">0</span>].values</span>
<span id="cb25-560"><a href="#cb25-560" aria-hidden="true" tabindex="-1"></a>        labels <span class="op">=</span> test_df[<span class="st">'Labels'</span>].values <span class="cf">if</span> <span class="st">'Labels'</span> <span class="kw">in</span> test_df.columns <span class="cf">else</span> test_df.iloc[:, <span class="dv">1</span>].values</span>
<span id="cb25-561"><a href="#cb25-561" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-562"><a href="#cb25-562" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Get true anomaly ranges</span></span>
<span id="cb25-563"><a href="#cb25-563" aria-hidden="true" tabindex="-1"></a>        true_ranges <span class="op">=</span> extract_true_anomaly_ranges(labels)</span>
<span id="cb25-564"><a href="#cb25-564" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-565"><a href="#cb25-565" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Detect anomalies using HIGH-PRECISION student's function</span></span>
<span id="cb25-566"><a href="#cb25-566" aria-hidden="true" tabindex="-1"></a>        predicted_ranges <span class="op">=</span> student_detect_anomalies(series)</span>
<span id="cb25-567"><a href="#cb25-567" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-568"><a href="#cb25-568" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Evaluate with formatted output</span></span>
<span id="cb25-569"><a href="#cb25-569" aria-hidden="true" tabindex="-1"></a>        metrics <span class="op">=</span> evaluate_anomaly_detection_formatted(true_ranges, predicted_ranges, file_idx<span class="op">=</span>idx)</span>
<span id="cb25-570"><a href="#cb25-570" aria-hidden="true" tabindex="-1"></a>        all_metrics.append(metrics)</span>
<span id="cb25-571"><a href="#cb25-571" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-572"><a href="#cb25-572" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Store detailed results</span></span>
<span id="cb25-573"><a href="#cb25-573" aria-hidden="true" tabindex="-1"></a>        detailed_results.append({</span>
<span id="cb25-574"><a href="#cb25-574" aria-hidden="true" tabindex="-1"></a>            <span class="st">'file_idx'</span>: idx,</span>
<span id="cb25-575"><a href="#cb25-575" aria-hidden="true" tabindex="-1"></a>            <span class="st">'true_ranges'</span>: true_ranges,</span>
<span id="cb25-576"><a href="#cb25-576" aria-hidden="true" tabindex="-1"></a>            <span class="st">'predicted_ranges'</span>: predicted_ranges,</span>
<span id="cb25-577"><a href="#cb25-577" aria-hidden="true" tabindex="-1"></a>            <span class="st">'metrics'</span>: metrics</span>
<span id="cb25-578"><a href="#cb25-578" aria-hidden="true" tabindex="-1"></a>        })</span>
<span id="cb25-579"><a href="#cb25-579" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-580"><a href="#cb25-580" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb25-581"><a href="#cb25-581" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Error processing file </span><span class="sc">{</span>idx<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-582"><a href="#cb25-582" aria-hidden="true" tabindex="-1"></a>        <span class="im">import</span> traceback</span>
<span id="cb25-583"><a href="#cb25-583" aria-hidden="true" tabindex="-1"></a>        traceback.print_exc()</span>
<span id="cb25-584"><a href="#cb25-584" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add zero metrics for failed files</span></span>
<span id="cb25-585"><a href="#cb25-585" aria-hidden="true" tabindex="-1"></a>        all_metrics.append({</span>
<span id="cb25-586"><a href="#cb25-586" aria-hidden="true" tabindex="-1"></a>            <span class="st">'accuracy'</span>: <span class="dv">0</span>,</span>
<span id="cb25-587"><a href="#cb25-587" aria-hidden="true" tabindex="-1"></a>            <span class="st">'precision'</span>: <span class="dv">0</span>,</span>
<span id="cb25-588"><a href="#cb25-588" aria-hidden="true" tabindex="-1"></a>            <span class="st">'recall'</span>: <span class="dv">0</span>,</span>
<span id="cb25-589"><a href="#cb25-589" aria-hidden="true" tabindex="-1"></a>            <span class="st">'f1_score'</span>: <span class="dv">0</span>,</span>
<span id="cb25-590"><a href="#cb25-590" aria-hidden="true" tabindex="-1"></a>            <span class="st">'true_positives'</span>: <span class="dv">0</span>,</span>
<span id="cb25-591"><a href="#cb25-591" aria-hidden="true" tabindex="-1"></a>            <span class="st">'false_positives'</span>: <span class="dv">0</span>,</span>
<span id="cb25-592"><a href="#cb25-592" aria-hidden="true" tabindex="-1"></a>            <span class="st">'false_negatives'</span>: <span class="dv">0</span>,</span>
<span id="cb25-593"><a href="#cb25-593" aria-hidden="true" tabindex="-1"></a>            <span class="st">'range_precision'</span>: <span class="dv">0</span>,</span>
<span id="cb25-594"><a href="#cb25-594" aria-hidden="true" tabindex="-1"></a>            <span class="st">'range_recall'</span>: <span class="dv">0</span>,</span>
<span id="cb25-595"><a href="#cb25-595" aria-hidden="true" tabindex="-1"></a>            <span class="st">'range_f1'</span>: <span class="dv">0</span>,</span>
<span id="cb25-596"><a href="#cb25-596" aria-hidden="true" tabindex="-1"></a>            <span class="st">'fully_detected'</span>: <span class="dv">0</span>,</span>
<span id="cb25-597"><a href="#cb25-597" aria-hidden="true" tabindex="-1"></a>            <span class="st">'partially_detected'</span>: <span class="dv">0</span>,</span>
<span id="cb25-598"><a href="#cb25-598" aria-hidden="true" tabindex="-1"></a>            <span class="st">'missed'</span>: <span class="dv">0</span>,</span>
<span id="cb25-599"><a href="#cb25-599" aria-hidden="true" tabindex="-1"></a>            <span class="st">'segment_detection_rate'</span>: <span class="dv">0</span>,</span>
<span id="cb25-600"><a href="#cb25-600" aria-hidden="true" tabindex="-1"></a>            <span class="st">'overall_detection_rate'</span>: <span class="dv">0</span>,</span>
<span id="cb25-601"><a href="#cb25-601" aria-hidden="true" tabindex="-1"></a>            <span class="st">'true_ranges'</span>: [],</span>
<span id="cb25-602"><a href="#cb25-602" aria-hidden="true" tabindex="-1"></a>            <span class="st">'predicted_ranges'</span>: [],</span>
<span id="cb25-603"><a href="#cb25-603" aria-hidden="true" tabindex="-1"></a>            <span class="st">'detection_details'</span>: [],</span>
<span id="cb25-604"><a href="#cb25-604" aria-hidden="true" tabindex="-1"></a>            <span class="st">'matched_pairs'</span>: []</span>
<span id="cb25-605"><a href="#cb25-605" aria-hidden="true" tabindex="-1"></a>        })</span>
<span id="cb25-606"><a href="#cb25-606" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-607"><a href="#cb25-607" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate overall summary statistics</span></span>
<span id="cb25-608"><a href="#cb25-608" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span> <span class="op">+</span> <span class="st">"="</span> <span class="op">*</span> <span class="dv">80</span>)</span>
<span id="cb25-609"><a href="#cb25-609" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"OVERALL SUMMARY ACROSS ALL FILES - HIGH-PRECISION VERSION"</span>)</span>
<span id="cb25-610"><a href="#cb25-610" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"="</span> <span class="op">*</span> <span class="dv">80</span>)</span>
<span id="cb25-611"><a href="#cb25-611" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-612"><a href="#cb25-612" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate basic metrics</span></span>
<span id="cb25-613"><a href="#cb25-613" aria-hidden="true" tabindex="-1"></a>overall_accuracy <span class="op">=</span> np.mean([m[<span class="st">'accuracy'</span>] <span class="cf">for</span> m <span class="kw">in</span> all_metrics])</span>
<span id="cb25-614"><a href="#cb25-614" aria-hidden="true" tabindex="-1"></a>overall_precision <span class="op">=</span> np.mean([m[<span class="st">'precision'</span>] <span class="cf">for</span> m <span class="kw">in</span> all_metrics])</span>
<span id="cb25-615"><a href="#cb25-615" aria-hidden="true" tabindex="-1"></a>overall_recall <span class="op">=</span> np.mean([m[<span class="st">'recall'</span>] <span class="cf">for</span> m <span class="kw">in</span> all_metrics])</span>
<span id="cb25-616"><a href="#cb25-616" aria-hidden="true" tabindex="-1"></a>overall_f1 <span class="op">=</span> np.mean([m[<span class="st">'f1_score'</span>] <span class="cf">for</span> m <span class="kw">in</span> all_metrics])</span>
<span id="cb25-617"><a href="#cb25-617" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-618"><a href="#cb25-618" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate range statistics</span></span>
<span id="cb25-619"><a href="#cb25-619" aria-hidden="true" tabindex="-1"></a>total_true_ranges <span class="op">=</span> <span class="bu">sum</span>([<span class="bu">len</span>(m[<span class="st">'true_ranges'</span>]) <span class="cf">for</span> m <span class="kw">in</span> all_metrics])</span>
<span id="cb25-620"><a href="#cb25-620" aria-hidden="true" tabindex="-1"></a>total_predicted_ranges <span class="op">=</span> <span class="bu">sum</span>([<span class="bu">len</span>(m[<span class="st">'predicted_ranges'</span>]) <span class="cf">for</span> m <span class="kw">in</span> all_metrics])</span>
<span id="cb25-621"><a href="#cb25-621" aria-hidden="true" tabindex="-1"></a>total_matched_ranges <span class="op">=</span> <span class="bu">sum</span>([<span class="bu">len</span>(m[<span class="st">'matched_pairs'</span>]) <span class="cf">for</span> m <span class="kw">in</span> all_metrics])</span>
<span id="cb25-622"><a href="#cb25-622" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-623"><a href="#cb25-623" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate other metrics</span></span>
<span id="cb25-624"><a href="#cb25-624" aria-hidden="true" tabindex="-1"></a>overall_range_precision <span class="op">=</span> np.mean([m[<span class="st">'range_precision'</span>] <span class="cf">for</span> m <span class="kw">in</span> all_metrics])</span>
<span id="cb25-625"><a href="#cb25-625" aria-hidden="true" tabindex="-1"></a>overall_range_recall <span class="op">=</span> np.mean([m[<span class="st">'range_recall'</span>] <span class="cf">for</span> m <span class="kw">in</span> all_metrics])</span>
<span id="cb25-626"><a href="#cb25-626" aria-hidden="true" tabindex="-1"></a>overall_range_f1 <span class="op">=</span> np.mean([m[<span class="st">'range_f1'</span>] <span class="cf">for</span> m <span class="kw">in</span> all_metrics])</span>
<span id="cb25-627"><a href="#cb25-627" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-628"><a href="#cb25-628" aria-hidden="true" tabindex="-1"></a>total_true_positives <span class="op">=</span> <span class="bu">sum</span>([m[<span class="st">'true_positives'</span>] <span class="cf">for</span> m <span class="kw">in</span> all_metrics])</span>
<span id="cb25-629"><a href="#cb25-629" aria-hidden="true" tabindex="-1"></a>total_false_positives <span class="op">=</span> <span class="bu">sum</span>([m[<span class="st">'false_positives'</span>] <span class="cf">for</span> m <span class="kw">in</span> all_metrics])</span>
<span id="cb25-630"><a href="#cb25-630" aria-hidden="true" tabindex="-1"></a>total_false_negatives <span class="op">=</span> <span class="bu">sum</span>([m[<span class="st">'false_negatives'</span>] <span class="cf">for</span> m <span class="kw">in</span> all_metrics])</span>
<span id="cb25-631"><a href="#cb25-631" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-632"><a href="#cb25-632" aria-hidden="true" tabindex="-1"></a>total_fully_detected <span class="op">=</span> <span class="bu">sum</span>([m[<span class="st">'fully_detected'</span>] <span class="cf">for</span> m <span class="kw">in</span> all_metrics])</span>
<span id="cb25-633"><a href="#cb25-633" aria-hidden="true" tabindex="-1"></a>total_partially_detected <span class="op">=</span> <span class="bu">sum</span>([m[<span class="st">'partially_detected'</span>] <span class="cf">for</span> m <span class="kw">in</span> all_metrics])</span>
<span id="cb25-634"><a href="#cb25-634" aria-hidden="true" tabindex="-1"></a>total_missed <span class="op">=</span> <span class="bu">sum</span>([m[<span class="st">'missed'</span>] <span class="cf">for</span> m <span class="kw">in</span> all_metrics])</span>
<span id="cb25-635"><a href="#cb25-635" aria-hidden="true" tabindex="-1"></a>total_segments <span class="op">=</span> total_fully_detected <span class="op">+</span> total_partially_detected <span class="op">+</span> total_missed</span>
<span id="cb25-636"><a href="#cb25-636" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-637"><a href="#cb25-637" aria-hidden="true" tabindex="-1"></a>overall_segment_detection_rate <span class="op">=</span> total_fully_detected <span class="op">/</span> total_segments <span class="cf">if</span> total_segments <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb25-638"><a href="#cb25-638" aria-hidden="true" tabindex="-1"></a>overall_detection_rate <span class="op">=</span> (total_fully_detected <span class="op">+</span> total_partially_detected) <span class="op">/</span> total_segments <span class="cf">if</span> total_segments <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb25-639"><a href="#cb25-639" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-640"><a href="#cb25-640" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Overall Basic Metrics:"</span>)</span>
<span id="cb25-641"><a href="#cb25-641" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Accuracy:  </span><span class="sc">{</span>overall_accuracy<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb25-642"><a href="#cb25-642" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Precision: </span><span class="sc">{</span>overall_precision<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb25-643"><a href="#cb25-643" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Recall:    </span><span class="sc">{</span>overall_recall<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb25-644"><a href="#cb25-644" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  F1-Score:  </span><span class="sc">{</span>overall_f1<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb25-645"><a href="#cb25-645" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>()</span>
<span id="cb25-646"><a href="#cb25-646" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Overall Range Statistics:"</span>)</span>
<span id="cb25-647"><a href="#cb25-647" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Total True Ranges: </span><span class="sc">{</span>total_true_ranges<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-648"><a href="#cb25-648" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Total Predicted Ranges: </span><span class="sc">{</span>total_predicted_ranges<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-649"><a href="#cb25-649" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Total Matched Ranges: </span><span class="sc">{</span>total_matched_ranges<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-650"><a href="#cb25-650" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Range Match Rate: </span><span class="sc">{</span>total_matched_ranges<span class="op">/</span>total_true_ranges<span class="sc">:.4f}</span><span class="ss">"</span> <span class="cf">if</span> total_true_ranges <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="st">"  Range Match Rate: 0.0000"</span>)</span>
<span id="cb25-651"><a href="#cb25-651" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>()</span>
<span id="cb25-652"><a href="#cb25-652" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Overall Range-based Metrics:"</span>)</span>
<span id="cb25-653"><a href="#cb25-653" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Range Precision: </span><span class="sc">{</span>overall_range_precision<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb25-654"><a href="#cb25-654" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Range Recall:    </span><span class="sc">{</span>overall_range_recall<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb25-655"><a href="#cb25-655" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Range F1:        </span><span class="sc">{</span>overall_range_f1<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb25-656"><a href="#cb25-656" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>()</span>
<span id="cb25-657"><a href="#cb25-657" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Overall Point-level Performance:"</span>)</span>
<span id="cb25-658"><a href="#cb25-658" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  True Positives:  </span><span class="sc">{</span>total_true_positives<span class="sc">}</span><span class="ss"> points"</span>)</span>
<span id="cb25-659"><a href="#cb25-659" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  False Positives: </span><span class="sc">{</span>total_false_positives<span class="sc">}</span><span class="ss"> points"</span>)</span>
<span id="cb25-660"><a href="#cb25-660" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  False Negatives: </span><span class="sc">{</span>total_false_negatives<span class="sc">}</span><span class="ss"> points"</span>)</span>
<span id="cb25-661"><a href="#cb25-661" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>()</span>
<span id="cb25-662"><a href="#cb25-662" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Overall Segment Detection Metrics:"</span>)</span>
<span id="cb25-663"><a href="#cb25-663" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Total Anomaly Segments: </span><span class="sc">{</span>total_segments<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-664"><a href="#cb25-664" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Fully Detected: </span><span class="sc">{</span>total_fully_detected<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-665"><a href="#cb25-665" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Partially Detected: </span><span class="sc">{</span>total_partially_detected<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-666"><a href="#cb25-666" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Missed: </span><span class="sc">{</span>total_missed<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-667"><a href="#cb25-667" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Segment Detection Rate: </span><span class="sc">{</span>overall_segment_detection_rate<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb25-668"><a href="#cb25-668" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Overall Detection Rate: </span><span class="sc">{</span>overall_detection_rate<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb25-669"><a href="#cb25-669" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-670"><a href="#cb25-670" aria-hidden="true" tabindex="-1"></a><span class="co"># File-by-file summary table</span></span>
<span id="cb25-671"><a href="#cb25-671" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span> <span class="op">+</span> <span class="st">"="</span> <span class="op">*</span> <span class="dv">80</span>)</span>
<span id="cb25-672"><a href="#cb25-672" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"FILE-BY-FILE SUMMARY - HIGH-PRECISION VERSION"</span>)</span>
<span id="cb25-673"><a href="#cb25-673" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"="</span> <span class="op">*</span> <span class="dv">80</span>)</span>
<span id="cb25-674"><a href="#cb25-674" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span><span class="st">'File'</span><span class="sc">:&lt;6}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Accuracy'</span><span class="sc">:&lt;10}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Precision'</span><span class="sc">:&lt;10}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Recall'</span><span class="sc">:&lt;10}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'F1-Score'</span><span class="sc">:&lt;10}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'True Ranges'</span><span class="sc">:&lt;12}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Pred Ranges'</span><span class="sc">:&lt;12}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Fully Det.'</span><span class="sc">:&lt;12}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Part. Det.'</span><span class="sc">:&lt;12}</span><span class="ss"> </span><span class="sc">{</span><span class="st">'Missed'</span><span class="sc">:&lt;8}</span><span class="ss">"</span>)</span>
<span id="cb25-675"><a href="#cb25-675" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"-"</span> <span class="op">*</span> <span class="dv">100</span>)</span>
<span id="cb25-676"><a href="#cb25-676" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-677"><a href="#cb25-677" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> idx, metrics <span class="kw">in</span> <span class="bu">enumerate</span>(all_metrics):</span>
<span id="cb25-678"><a href="#cb25-678" aria-hidden="true" tabindex="-1"></a>    true_range_count <span class="op">=</span> <span class="bu">len</span>(metrics[<span class="st">'true_ranges'</span>])</span>
<span id="cb25-679"><a href="#cb25-679" aria-hidden="true" tabindex="-1"></a>    pred_range_count <span class="op">=</span> <span class="bu">len</span>(metrics[<span class="st">'predicted_ranges'</span>])</span>
<span id="cb25-680"><a href="#cb25-680" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-681"><a href="#cb25-681" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>idx<span class="sc">:&lt;6}</span><span class="ss"> </span><span class="sc">{</span>metrics[<span class="st">'accuracy'</span>]<span class="sc">:.4f}</span><span class="ss">    </span><span class="sc">{</span>metrics[<span class="st">'precision'</span>]<span class="sc">:.4f}</span><span class="ss">     </span><span class="sc">{</span>metrics[<span class="st">'recall'</span>]<span class="sc">:.4f}</span><span class="ss">     </span><span class="sc">{</span>metrics[<span class="st">'f1_score'</span>]<span class="sc">:.4f}</span><span class="ss">     "</span></span>
<span id="cb25-682"><a href="#cb25-682" aria-hidden="true" tabindex="-1"></a>          <span class="ss">f"</span><span class="sc">{</span>true_range_count<span class="sc">:&lt;11}</span><span class="ss"> </span><span class="sc">{</span>pred_range_count<span class="sc">:&lt;11}</span><span class="ss"> </span><span class="sc">{</span>metrics[<span class="st">'fully_detected'</span>]<span class="sc">:&lt;11}</span><span class="ss"> </span><span class="sc">{</span>metrics[<span class="st">'partially_detected'</span>]<span class="sc">:&lt;11}</span><span class="ss"> </span><span class="sc">{</span>metrics[<span class="st">'missed'</span>]<span class="sc">:&lt;8}</span><span class="ss">"</span>)</span>
<span id="cb25-683"><a href="#cb25-683" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-684"><a href="#cb25-684" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"-"</span> <span class="op">*</span> <span class="dv">100</span>)</span>
<span id="cb25-685"><a href="#cb25-685" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-686"><a href="#cb25-686" aria-hidden="true" tabindex="-1"></a><span class="co"># Detailed range information for each file</span></span>
<span id="cb25-687"><a href="#cb25-687" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span> <span class="op">+</span> <span class="st">"="</span> <span class="op">*</span> <span class="dv">80</span>)</span>
<span id="cb25-688"><a href="#cb25-688" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"DETAILED RANGE INFORMATION BY FILE"</span>)</span>
<span id="cb25-689"><a href="#cb25-689" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"="</span> <span class="op">*</span> <span class="dv">80</span>)</span>
<span id="cb25-690"><a href="#cb25-690" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-691"><a href="#cb25-691" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> result <span class="kw">in</span> detailed_results:</span>
<span id="cb25-692"><a href="#cb25-692" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> result[<span class="st">'metrics'</span>][<span class="st">'true_ranges'</span>] <span class="kw">or</span> result[<span class="st">'metrics'</span>][<span class="st">'predicted_ranges'</span>]:</span>
<span id="cb25-693"><a href="#cb25-693" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">File </span><span class="sc">{</span>result[<span class="st">'file_idx'</span>]<span class="sc">}</span><span class="ss">:"</span>)</span>
<span id="cb25-694"><a href="#cb25-694" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"  True Ranges: </span><span class="sc">{</span>result[<span class="st">'true_ranges'</span>]<span class="sc">}</span><span class="ss"> (count: </span><span class="sc">{</span><span class="bu">len</span>(result[<span class="st">'true_ranges'</span>])<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb25-695"><a href="#cb25-695" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"  Predicted Ranges: </span><span class="sc">{</span>result[<span class="st">'predicted_ranges'</span>]<span class="sc">}</span><span class="ss"> (count: </span><span class="sc">{</span><span class="bu">len</span>(result[<span class="st">'predicted_ranges'</span>])<span class="sc">}</span><span class="ss">)"</span>)</span>
<span id="cb25-696"><a href="#cb25-696" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-697"><a href="#cb25-697" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Show matching information</span></span>
<span id="cb25-698"><a href="#cb25-698" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> result[<span class="st">'metrics'</span>][<span class="st">'matched_pairs'</span>]:</span>
<span id="cb25-699"><a href="#cb25-699" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"  Matched Pairs:"</span>)</span>
<span id="cb25-700"><a href="#cb25-700" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> match <span class="kw">in</span> result[<span class="st">'metrics'</span>][<span class="st">'matched_pairs'</span>]:</span>
<span id="cb25-701"><a href="#cb25-701" aria-hidden="true" tabindex="-1"></a>                true_idx, pred_range, true_range <span class="op">=</span> match</span>
<span id="cb25-702"><a href="#cb25-702" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="ss">f"    True Range </span><span class="sc">{</span>true_idx<span class="sc">}</span><span class="ss"> </span><span class="sc">{</span>true_range<span class="sc">}</span><span class="ss"> ↔ Predicted </span><span class="sc">{</span>pred_range<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb25-703"><a href="#cb25-703" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-704"><a href="#cb25-704" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Evaluation completed for all files with high-precision detection methods!"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Starting HIGH-PRECISION Anomaly Detection Evaluation
Key improvements for higher precision:
- Contamination range: 0.05-0.2 (reduced from 0.1-0.4)
- Z-score threshold: 3.0 (maintained)
- Stricter range grouping (max_gap=5, min_length=3)
- Anti-overfitting measures (more trees, smaller samples)
- More selective range merging and combination
================================================================================

================================================================================
Optimal contamination for precision: 0.0500
Detected 16 high-confidence anomaly ranges
Isolation Forest ranges: 19, Z-score ranges: 3
EVALUATION RESULTS - FILE 0
============================================================
Range Information:
  True Ranges: [(np.int64(2533), np.int64(2620)), (np.int64(2864), np.int64(2949)), (np.int64(4811), np.int64(4910)), (np.int64(5148), np.int64(5304)), (np.int64(5492), np.int64(5619)), (np.int64(5986), np.int64(6016)), (np.int64(6222), np.int64(6257)), (np.int64(7088), np.int64(7117)), (np.int64(7599), np.int64(7716)), (np.int64(8633), np.int64(8750))] (count: 10)
  Predicted Ranges: [(np.int64(0), np.int64(9)), (np.int64(2533), np.int64(2617)), (np.int64(2860), np.int64(2954)), (np.int64(4808), np.int64(4817)), (np.int64(4900), np.int64(4912)), (np.int64(5236), np.int64(5245)), (np.int64(5291), np.int64(5308)), (np.int64(5491), np.int64(5503)), (np.int64(5608), np.int64(5624)), (np.int64(5982), np.int64(6017)), (np.int64(6219), np.int64(6258)), (np.int64(7084), np.int64(7122)), (np.int64(7595), np.int64(7613)), (np.int64(7711), np.int64(7718)), (np.int64(8628), np.int64(8756)), (np.int64(9986), np.int64(9999))] (count: 16)

Detection Details by Segment:
  Segment 0: (np.int64(2533), np.int64(2620)) ✓ FULL (85/88 points, 96.6%)
    → Overlap with predicted range (np.int64(2533), np.int64(2617)): 85 points
  Segment 1: (np.int64(2864), np.int64(2949)) ✓ FULL (86/86 points, 100.0%)
    → Overlap with predicted range (np.int64(2860), np.int64(2954)): 86 points
  Segment 2: (np.int64(4811), np.int64(4910)) ~ PARTIAL (18/100 points, 18.0%)
    → Overlap with predicted range (np.int64(4808), np.int64(4817)): 7 points
    → Overlap with predicted range (np.int64(4900), np.int64(4912)): 11 points
  Segment 3: (np.int64(5148), np.int64(5304)) ~ PARTIAL (24/157 points, 15.3%)
    → Overlap with predicted range (np.int64(5236), np.int64(5245)): 10 points
    → Overlap with predicted range (np.int64(5291), np.int64(5308)): 14 points
  Segment 4: (np.int64(5492), np.int64(5619)) ~ PARTIAL (24/128 points, 18.8%)
    → Overlap with predicted range (np.int64(5491), np.int64(5503)): 12 points
    → Overlap with predicted range (np.int64(5608), np.int64(5624)): 12 points
  Segment 5: (np.int64(5986), np.int64(6016)) ✓ FULL (31/31 points, 100.0%)
    → Overlap with predicted range (np.int64(5982), np.int64(6017)): 31 points
  Segment 6: (np.int64(6222), np.int64(6257)) ✓ FULL (36/36 points, 100.0%)
    → Overlap with predicted range (np.int64(6219), np.int64(6258)): 36 points
  Segment 7: (np.int64(7088), np.int64(7117)) ✓ FULL (30/30 points, 100.0%)
    → Overlap with predicted range (np.int64(7084), np.int64(7122)): 30 points
  Segment 8: (np.int64(7599), np.int64(7716)) ~ PARTIAL (21/118 points, 17.8%)
    → Overlap with predicted range (np.int64(7595), np.int64(7613)): 15 points
    → Overlap with predicted range (np.int64(7711), np.int64(7718)): 6 points
  Segment 9: (np.int64(8633), np.int64(8750)) ✓ FULL (118/118 points, 100.0%)
    → Overlap with predicted range (np.int64(8628), np.int64(8756)): 118 points

Basic Metrics:
  Accuracy:  0.9498
  Precision: 0.8507
  Recall:    0.5303
  F1-Score:  0.6533

Anomaly Statistics:
  True Anomalies: 892 points
  Predicted Anomalies: 556 points
  Detection Rate: 0.5303

Range-based Metrics:
  Range Precision: 0.6250
  Range Recall:    1.0000
  Range F1:        0.7692

Point-level Performance:
  True Positives:  473 points
  False Positives: 83 points
  False Negatives: 419 points

Segment Detection Metrics:
  Total Anomaly Segments: 10
  Fully Detected: 6
  Partially Detected: 4
  Missed: 0
  Segment Detection Rate: 0.6000
  Overall Detection Rate: 1.0000


================================================================================
Optimal contamination for precision: 0.0500
Detected 16 high-confidence anomaly ranges
Isolation Forest ranges: 23, Z-score ranges: 8
EVALUATION RESULTS - FILE 1
============================================================
Range Information:
  True Ranges: [(np.int64(2206), np.int64(2325)), (np.int64(2864), np.int64(2978)), (np.int64(3483), np.int64(3565)), (np.int64(3834), np.int64(3926)), (np.int64(4758), np.int64(4878)), (np.int64(6850), np.int64(6957)), (np.int64(7852), np.int64(7954)), (np.int64(8319), np.int64(8428)), (np.int64(9112), np.int64(9225)), (np.int64(9372), np.int64(9471))] (count: 10)
  Predicted Ranges: [(np.int64(0), np.int64(9)), (np.int64(2205), np.int64(2327)), (np.int64(2930), np.int64(2981)), (np.int64(3482), np.int64(3567)), (np.int64(3830), np.int64(3931)), (np.int64(4757), np.int64(4882)), (np.int64(6856), np.int64(6862)), (np.int64(6904), np.int64(6910)), (np.int64(6928), np.int64(6934)), (np.int64(7901), np.int64(7906)), (np.int64(7918), np.int64(7959)), (np.int64(8377), np.int64(8430)), (np.int64(9160), np.int64(9166)), (np.int64(9184), np.int64(9190)), (np.int64(9391), np.int64(9476)), (np.int64(9990), np.int64(9999))] (count: 16)

Detection Details by Segment:
  Segment 0: (np.int64(2206), np.int64(2325)) ✓ FULL (120/120 points, 100.0%)
    → Overlap with predicted range (np.int64(2205), np.int64(2327)): 120 points
  Segment 1: (np.int64(2864), np.int64(2978)) ~ PARTIAL (49/115 points, 42.6%)
    → Overlap with predicted range (np.int64(2930), np.int64(2981)): 49 points
  Segment 2: (np.int64(3483), np.int64(3565)) ✓ FULL (83/83 points, 100.0%)
    → Overlap with predicted range (np.int64(3482), np.int64(3567)): 83 points
  Segment 3: (np.int64(3834), np.int64(3926)) ✓ FULL (93/93 points, 100.0%)
    → Overlap with predicted range (np.int64(3830), np.int64(3931)): 93 points
  Segment 4: (np.int64(4758), np.int64(4878)) ✓ FULL (121/121 points, 100.0%)
    → Overlap with predicted range (np.int64(4757), np.int64(4882)): 121 points
  Segment 5: (np.int64(6850), np.int64(6957)) ~ PARTIAL (21/108 points, 19.4%)
    → Overlap with predicted range (np.int64(6856), np.int64(6862)): 7 points
    → Overlap with predicted range (np.int64(6904), np.int64(6910)): 7 points
    → Overlap with predicted range (np.int64(6928), np.int64(6934)): 7 points
  Segment 6: (np.int64(7852), np.int64(7954)) ~ PARTIAL (43/103 points, 41.7%)
    → Overlap with predicted range (np.int64(7901), np.int64(7906)): 6 points
    → Overlap with predicted range (np.int64(7918), np.int64(7959)): 37 points
  Segment 7: (np.int64(8319), np.int64(8428)) ~ PARTIAL (52/110 points, 47.3%)
    → Overlap with predicted range (np.int64(8377), np.int64(8430)): 52 points
  Segment 8: (np.int64(9112), np.int64(9225)) ~ PARTIAL (14/114 points, 12.3%)
    → Overlap with predicted range (np.int64(9160), np.int64(9166)): 7 points
    → Overlap with predicted range (np.int64(9184), np.int64(9190)): 7 points
  Segment 9: (np.int64(9372), np.int64(9471)) ✓ FULL (81/100 points, 81.0%)
    → Overlap with predicted range (np.int64(9391), np.int64(9476)): 81 points

Basic Metrics:
  Accuracy:  0.9555
  Precision: 0.9249
  Recall:    0.6345
  F1-Score:  0.7526

Anomaly Statistics:
  True Anomalies: 1067 points
  Predicted Anomalies: 732 points
  Detection Rate: 0.6345

Range-based Metrics:
  Range Precision: 0.6250
  Range Recall:    1.0000
  Range F1:        0.7692

Point-level Performance:
  True Positives:  677 points
  False Positives: 55 points
  False Negatives: 390 points

Segment Detection Metrics:
  Total Anomaly Segments: 10
  Fully Detected: 5
  Partially Detected: 5
  Missed: 0
  Segment Detection Rate: 0.5000
  Overall Detection Rate: 1.0000


================================================================================
Optimal contamination for precision: 0.0500
Detected 19 high-confidence anomaly ranges
Isolation Forest ranges: 19, Z-score ranges: 9
EVALUATION RESULTS - FILE 2
============================================================
Range Information:
  True Ranges: [(np.int64(2657), np.int64(2755)), (np.int64(3755), np.int64(3860)), (np.int64(3991), np.int64(4011)), (np.int64(4429), np.int64(4558)), (np.int64(4968), np.int64(5070)), (np.int64(6624), np.int64(6713)), (np.int64(7931), np.int64(8008)), (np.int64(8129), np.int64(8159)), (np.int64(9307), np.int64(9393)), (np.int64(9752), np.int64(9790))] (count: 10)
  Predicted Ranges: [(np.int64(0), np.int64(9)), (np.int64(2681), np.int64(2687)), (np.int64(2699), np.int64(2711)), (np.int64(2729), np.int64(2735)), (np.int64(2747), np.int64(2755)), (np.int64(3761), np.int64(3767)), (np.int64(3785), np.int64(3791)), (np.int64(3803), np.int64(3815)), (np.int64(3833), np.int64(3839)), (np.int64(3988), np.int64(4013)), (np.int64(4487), np.int64(4562)), (np.int64(4964), np.int64(5075)), (np.int64(6655), np.int64(6718)), (np.int64(7961), np.int64(7967)), (np.int64(7979), np.int64(7991)), (np.int64(8126), np.int64(8163)), (np.int64(9350), np.int64(9397)), (np.int64(9749), np.int64(9795)), (np.int64(9989), np.int64(9999))] (count: 19)

Detection Details by Segment:
  Segment 0: (np.int64(2657), np.int64(2755)) ~ PARTIAL (36/99 points, 36.4%)
    → Overlap with predicted range (np.int64(2681), np.int64(2687)): 7 points
    → Overlap with predicted range (np.int64(2699), np.int64(2711)): 13 points
    → Overlap with predicted range (np.int64(2729), np.int64(2735)): 7 points
    → Overlap with predicted range (np.int64(2747), np.int64(2755)): 9 points
  Segment 1: (np.int64(3755), np.int64(3860)) ~ PARTIAL (34/106 points, 32.1%)
    → Overlap with predicted range (np.int64(3761), np.int64(3767)): 7 points
    → Overlap with predicted range (np.int64(3785), np.int64(3791)): 7 points
    → Overlap with predicted range (np.int64(3803), np.int64(3815)): 13 points
    → Overlap with predicted range (np.int64(3833), np.int64(3839)): 7 points
  Segment 2: (np.int64(3991), np.int64(4011)) ✓ FULL (21/21 points, 100.0%)
    → Overlap with predicted range (np.int64(3988), np.int64(4013)): 21 points
  Segment 3: (np.int64(4429), np.int64(4558)) ~ PARTIAL (72/130 points, 55.4%)
    → Overlap with predicted range (np.int64(4487), np.int64(4562)): 72 points
  Segment 4: (np.int64(4968), np.int64(5070)) ✓ FULL (103/103 points, 100.0%)
    → Overlap with predicted range (np.int64(4964), np.int64(5075)): 103 points
  Segment 5: (np.int64(6624), np.int64(6713)) ~ PARTIAL (59/90 points, 65.6%)
    → Overlap with predicted range (np.int64(6655), np.int64(6718)): 59 points
  Segment 6: (np.int64(7931), np.int64(8008)) ~ PARTIAL (20/78 points, 25.6%)
    → Overlap with predicted range (np.int64(7961), np.int64(7967)): 7 points
    → Overlap with predicted range (np.int64(7979), np.int64(7991)): 13 points
  Segment 7: (np.int64(8129), np.int64(8159)) ✓ FULL (31/31 points, 100.0%)
    → Overlap with predicted range (np.int64(8126), np.int64(8163)): 31 points
  Segment 8: (np.int64(9307), np.int64(9393)) ~ PARTIAL (44/87 points, 50.6%)
    → Overlap with predicted range (np.int64(9350), np.int64(9397)): 44 points
  Segment 9: (np.int64(9752), np.int64(9790)) ✓ FULL (39/39 points, 100.0%)
    → Overlap with predicted range (np.int64(9749), np.int64(9795)): 39 points

Basic Metrics:
  Accuracy:  0.9612
  Precision: 0.8793
  Recall:    0.5855
  F1-Score:  0.7029

Anomaly Statistics:
  True Anomalies: 784 points
  Predicted Anomalies: 522 points
  Detection Rate: 0.5855

Range-based Metrics:
  Range Precision: 0.5263
  Range Recall:    1.0000
  Range F1:        0.6897

Point-level Performance:
  True Positives:  459 points
  False Positives: 63 points
  False Negatives: 325 points

Segment Detection Metrics:
  Total Anomaly Segments: 10
  Fully Detected: 4
  Partially Detected: 6
  Missed: 0
  Segment Detection Rate: 0.4000
  Overall Detection Rate: 1.0000


================================================================================
Optimal contamination for precision: 0.0500
Detected 20 high-confidence anomaly ranges
Isolation Forest ranges: 21, Z-score ranges: 3
EVALUATION RESULTS - FILE 3
============================================================
Range Information:
  True Ranges: [(np.int64(2240), np.int64(2338)), (np.int64(2824), np.int64(2912)), (np.int64(3685), np.int64(3792)), (np.int64(4212), np.int64(4244)), (np.int64(5007), np.int64(5029)), (np.int64(5758), np.int64(5870)), (np.int64(6665), np.int64(6777)), (np.int64(8492), np.int64(8521)), (np.int64(9099), np.int64(9197)), (np.int64(9628), np.int64(9724))] (count: 10)
  Predicted Ranges: [(np.int64(0), np.int64(24)), (np.int64(2282), np.int64(2291)), (np.int64(2334), np.int64(2342)), (np.int64(2824), np.int64(2909)), (np.int64(3681), np.int64(3689)), (np.int64(3732), np.int64(3744)), (np.int64(3787), np.int64(3797)), (np.int64(4210), np.int64(4248)), (np.int64(5003), np.int64(5034)), (np.int64(5755), np.int64(5762)), (np.int64(5804), np.int64(5824)), (np.int64(5865), np.int64(5874)), (np.int64(6661), np.int64(6678)), (np.int64(6713), np.int64(6729)), (np.int64(6772), np.int64(6781)), (np.int64(8486), np.int64(8527)), (np.int64(9137), np.int64(9155)), (np.int64(9184), np.int64(9202)), (np.int64(9628), np.int64(9725)), (np.int64(9976), np.int64(9999))] (count: 20)

Detection Details by Segment:
  Segment 0: (np.int64(2240), np.int64(2338)) ~ PARTIAL (15/99 points, 15.2%)
    → Overlap with predicted range (np.int64(2282), np.int64(2291)): 10 points
    → Overlap with predicted range (np.int64(2334), np.int64(2342)): 5 points
  Segment 1: (np.int64(2824), np.int64(2912)) ✓ FULL (86/89 points, 96.6%)
    → Overlap with predicted range (np.int64(2824), np.int64(2909)): 86 points
  Segment 2: (np.int64(3685), np.int64(3792)) ~ PARTIAL (24/108 points, 22.2%)
    → Overlap with predicted range (np.int64(3681), np.int64(3689)): 5 points
    → Overlap with predicted range (np.int64(3732), np.int64(3744)): 13 points
    → Overlap with predicted range (np.int64(3787), np.int64(3797)): 6 points
  Segment 3: (np.int64(4212), np.int64(4244)) ✓ FULL (33/33 points, 100.0%)
    → Overlap with predicted range (np.int64(4210), np.int64(4248)): 33 points
  Segment 4: (np.int64(5007), np.int64(5029)) ✓ FULL (23/23 points, 100.0%)
    → Overlap with predicted range (np.int64(5003), np.int64(5034)): 23 points
  Segment 5: (np.int64(5758), np.int64(5870)) ~ PARTIAL (32/113 points, 28.3%)
    → Overlap with predicted range (np.int64(5755), np.int64(5762)): 5 points
    → Overlap with predicted range (np.int64(5804), np.int64(5824)): 21 points
    → Overlap with predicted range (np.int64(5865), np.int64(5874)): 6 points
  Segment 6: (np.int64(6665), np.int64(6777)) ~ PARTIAL (37/113 points, 32.7%)
    → Overlap with predicted range (np.int64(6661), np.int64(6678)): 14 points
    → Overlap with predicted range (np.int64(6713), np.int64(6729)): 17 points
    → Overlap with predicted range (np.int64(6772), np.int64(6781)): 6 points
  Segment 7: (np.int64(8492), np.int64(8521)) ✓ FULL (30/30 points, 100.0%)
    → Overlap with predicted range (np.int64(8486), np.int64(8527)): 30 points
  Segment 8: (np.int64(9099), np.int64(9197)) ~ PARTIAL (33/99 points, 33.3%)
    → Overlap with predicted range (np.int64(9137), np.int64(9155)): 19 points
    → Overlap with predicted range (np.int64(9184), np.int64(9202)): 14 points
  Segment 9: (np.int64(9628), np.int64(9724)) ✓ FULL (97/97 points, 100.0%)
    → Overlap with predicted range (np.int64(9628), np.int64(9725)): 97 points

Basic Metrics:
  Accuracy:  0.9496
  Precision: 0.7885
  Recall:    0.5100
  F1-Score:  0.6193

Anomaly Statistics:
  True Anomalies: 804 points
  Predicted Anomalies: 520 points
  Detection Rate: 0.5100

Range-based Metrics:
  Range Precision: 0.5000
  Range Recall:    1.0000
  Range F1:        0.6667

Point-level Performance:
  True Positives:  410 points
  False Positives: 110 points
  False Negatives: 394 points

Segment Detection Metrics:
  Total Anomaly Segments: 10
  Fully Detected: 5
  Partially Detected: 5
  Missed: 0
  Segment Detection Rate: 0.5000
  Overall Detection Rate: 1.0000


================================================================================
Optimal contamination for precision: 0.0500
Detected 12 high-confidence anomaly ranges
Isolation Forest ranges: 15, Z-score ranges: 9
EVALUATION RESULTS - FILE 4
============================================================
Range Information:
  True Ranges: [(np.int64(2229), np.int64(2272)), (np.int64(2744), np.int64(2840)), (np.int64(3010), np.int64(3034)), (np.int64(3761), np.int64(3783)), (np.int64(5028), np.int64(5065)), (np.int64(6270), np.int64(6304)), (np.int64(8383), np.int64(8422)), (np.int64(8650), np.int64(8730)), (np.int64(9602), np.int64(9627)), (np.int64(9862), np.int64(9960))] (count: 10)
  Predicted Ranges: [(np.int64(0), np.int64(9)), (np.int64(2225), np.int64(2276)), (np.int64(2740), np.int64(2845)), (np.int64(3008), np.int64(3038)), (np.int64(3759), np.int64(3786)), (np.int64(5025), np.int64(5068)), (np.int64(6267), np.int64(6305)), (np.int64(8380), np.int64(8427)), (np.int64(8685), np.int64(8735)), (np.int64(9599), np.int64(9632)), (np.int64(9874), np.int64(9960)), (np.int64(9990), np.int64(9999))] (count: 12)

Detection Details by Segment:
  Segment 0: (np.int64(2229), np.int64(2272)) ✓ FULL (44/44 points, 100.0%)
    → Overlap with predicted range (np.int64(2225), np.int64(2276)): 44 points
  Segment 1: (np.int64(2744), np.int64(2840)) ✓ FULL (97/97 points, 100.0%)
    → Overlap with predicted range (np.int64(2740), np.int64(2845)): 97 points
  Segment 2: (np.int64(3010), np.int64(3034)) ✓ FULL (25/25 points, 100.0%)
    → Overlap with predicted range (np.int64(3008), np.int64(3038)): 25 points
  Segment 3: (np.int64(3761), np.int64(3783)) ✓ FULL (23/23 points, 100.0%)
    → Overlap with predicted range (np.int64(3759), np.int64(3786)): 23 points
  Segment 4: (np.int64(5028), np.int64(5065)) ✓ FULL (38/38 points, 100.0%)
    → Overlap with predicted range (np.int64(5025), np.int64(5068)): 38 points
  Segment 5: (np.int64(6270), np.int64(6304)) ✓ FULL (35/35 points, 100.0%)
    → Overlap with predicted range (np.int64(6267), np.int64(6305)): 35 points
  Segment 6: (np.int64(8383), np.int64(8422)) ✓ FULL (40/40 points, 100.0%)
    → Overlap with predicted range (np.int64(8380), np.int64(8427)): 40 points
  Segment 7: (np.int64(8650), np.int64(8730)) ~ PARTIAL (46/81 points, 56.8%)
    → Overlap with predicted range (np.int64(8685), np.int64(8735)): 46 points
  Segment 8: (np.int64(9602), np.int64(9627)) ✓ FULL (26/26 points, 100.0%)
    → Overlap with predicted range (np.int64(9599), np.int64(9632)): 26 points
  Segment 9: (np.int64(9862), np.int64(9960)) ✓ FULL (87/99 points, 87.9%)
    → Overlap with predicted range (np.int64(9874), np.int64(9960)): 87 points

Basic Metrics:
  Accuracy:  0.9874
  Precision: 0.8537
  Recall:    0.9075
  F1-Score:  0.8798

Anomaly Statistics:
  True Anomalies: 508 points
  Predicted Anomalies: 540 points
  Detection Rate: 0.9075

Range-based Metrics:
  Range Precision: 0.8333
  Range Recall:    1.0000
  Range F1:        0.9091

Point-level Performance:
  True Positives:  461 points
  False Positives: 79 points
  False Negatives: 47 points

Segment Detection Metrics:
  Total Anomaly Segments: 10
  Fully Detected: 9
  Partially Detected: 1
  Missed: 0
  Segment Detection Rate: 0.9000
  Overall Detection Rate: 1.0000


================================================================================
Optimal contamination for precision: 0.0500
Detected 21 high-confidence anomaly ranges
Isolation Forest ranges: 23, Z-score ranges: 7
EVALUATION RESULTS - FILE 5
============================================================
Range Information:
  True Ranges: [(np.int64(2661), np.int64(2775)), (np.int64(2863), np.int64(2894)), (np.int64(3006), np.int64(3124)), (np.int64(4118), np.int64(4269)), (np.int64(4463), np.int64(4591)), (np.int64(5953), np.int64(5994)), (np.int64(6107), np.int64(6225)), (np.int64(6429), np.int64(6577)), (np.int64(7969), np.int64(8094)), (np.int64(8886), np.int64(8906))] (count: 10)
  Predicted Ranges: [(np.int64(0), np.int64(9)), (np.int64(2679), np.int64(2685)), (np.int64(2703), np.int64(2715)), (np.int64(2727), np.int64(2733)), (np.int64(2863), np.int64(2897)), (np.int64(3004), np.int64(3010)), (np.int64(3056), np.int64(3075)), (np.int64(3121), np.int64(3127)), (np.int64(4180), np.int64(4274)), (np.int64(4463), np.int64(4466)), (np.int64(4513), np.int64(4542)), (np.int64(4588), np.int64(4594)), (np.int64(5950), np.int64(5998)), (np.int64(6137), np.int64(6167)), (np.int64(6179), np.int64(6215)), (np.int64(6484), np.int64(6581)), (np.int64(7968), np.int64(7979)), (np.int64(8019), np.int64(8045)), (np.int64(8083), np.int64(8098)), (np.int64(8885), np.int64(8909)), (np.int64(9984), np.int64(9999))] (count: 21)

Detection Details by Segment:
  Segment 0: (np.int64(2661), np.int64(2775)) ~ PARTIAL (27/115 points, 23.5%)
    → Overlap with predicted range (np.int64(2679), np.int64(2685)): 7 points
    → Overlap with predicted range (np.int64(2703), np.int64(2715)): 13 points
    → Overlap with predicted range (np.int64(2727), np.int64(2733)): 7 points
  Segment 1: (np.int64(2863), np.int64(2894)) ✓ FULL (32/32 points, 100.0%)
    → Overlap with predicted range (np.int64(2863), np.int64(2897)): 32 points
  Segment 2: (np.int64(3006), np.int64(3124)) ~ PARTIAL (29/119 points, 24.4%)
    → Overlap with predicted range (np.int64(3004), np.int64(3010)): 5 points
    → Overlap with predicted range (np.int64(3056), np.int64(3075)): 20 points
    → Overlap with predicted range (np.int64(3121), np.int64(3127)): 4 points
  Segment 3: (np.int64(4118), np.int64(4269)) ~ PARTIAL (90/152 points, 59.2%)
    → Overlap with predicted range (np.int64(4180), np.int64(4274)): 90 points
  Segment 4: (np.int64(4463), np.int64(4591)) ~ PARTIAL (38/129 points, 29.5%)
    → Overlap with predicted range (np.int64(4463), np.int64(4466)): 4 points
    → Overlap with predicted range (np.int64(4513), np.int64(4542)): 30 points
    → Overlap with predicted range (np.int64(4588), np.int64(4594)): 4 points
  Segment 5: (np.int64(5953), np.int64(5994)) ✓ FULL (42/42 points, 100.0%)
    → Overlap with predicted range (np.int64(5950), np.int64(5998)): 42 points
  Segment 6: (np.int64(6107), np.int64(6225)) ~ PARTIAL (68/119 points, 57.1%)
    → Overlap with predicted range (np.int64(6137), np.int64(6167)): 31 points
    → Overlap with predicted range (np.int64(6179), np.int64(6215)): 37 points
  Segment 7: (np.int64(6429), np.int64(6577)) ~ PARTIAL (94/149 points, 63.1%)
    → Overlap with predicted range (np.int64(6484), np.int64(6581)): 94 points
  Segment 8: (np.int64(7969), np.int64(8094)) ~ PARTIAL (50/126 points, 39.7%)
    → Overlap with predicted range (np.int64(7968), np.int64(7979)): 11 points
    → Overlap with predicted range (np.int64(8019), np.int64(8045)): 27 points
    → Overlap with predicted range (np.int64(8083), np.int64(8098)): 12 points
  Segment 9: (np.int64(8886), np.int64(8906)) ✓ FULL (21/21 points, 100.0%)
    → Overlap with predicted range (np.int64(8885), np.int64(8909)): 21 points

Basic Metrics:
  Accuracy:  0.9425
  Precision: 0.8879
  Recall:    0.4890
  F1-Score:  0.6307

Anomaly Statistics:
  True Anomalies: 1004 points
  Predicted Anomalies: 553 points
  Detection Rate: 0.4890

Range-based Metrics:
  Range Precision: 0.4762
  Range Recall:    1.0000
  Range F1:        0.6452

Point-level Performance:
  True Positives:  491 points
  False Positives: 62 points
  False Negatives: 513 points

Segment Detection Metrics:
  Total Anomaly Segments: 10
  Fully Detected: 3
  Partially Detected: 7
  Missed: 0
  Segment Detection Rate: 0.3000
  Overall Detection Rate: 1.0000


================================================================================
Optimal contamination for precision: 0.0500
Detected 13 high-confidence anomaly ranges
Isolation Forest ranges: 23, Z-score ranges: 9
EVALUATION RESULTS - FILE 6
============================================================
Range Information:
  True Ranges: [(np.int64(2543), np.int64(2670)), (np.int64(3004), np.int64(3087)), (np.int64(3766), np.int64(3826)), (np.int64(5188), np.int64(5304)), (np.int64(5882), np.int64(5908)), (np.int64(6584), np.int64(6609)), (np.int64(7041), np.int64(7143)), (np.int64(7441), np.int64(7539)), (np.int64(9294), np.int64(9429)), (np.int64(9817), np.int64(9846))] (count: 10)
  Predicted Ranges: [(np.int64(0), np.int64(9)), (np.int64(2541), np.int64(2672)), (np.int64(3047), np.int64(3089)), (np.int64(3784), np.int64(3790)), (np.int64(3808), np.int64(3814)), (np.int64(5255), np.int64(5308)), (np.int64(5880), np.int64(5911)), (np.int64(6584), np.int64(6612)), (np.int64(7038), np.int64(7148)), (np.int64(7438), np.int64(7542)), (np.int64(9360), np.int64(9434)), (np.int64(9815), np.int64(9849)), (np.int64(9991), np.int64(9999))] (count: 13)

Detection Details by Segment:
  Segment 0: (np.int64(2543), np.int64(2670)) ✓ FULL (128/128 points, 100.0%)
    → Overlap with predicted range (np.int64(2541), np.int64(2672)): 128 points
  Segment 1: (np.int64(3004), np.int64(3087)) ~ PARTIAL (41/84 points, 48.8%)
    → Overlap with predicted range (np.int64(3047), np.int64(3089)): 41 points
  Segment 2: (np.int64(3766), np.int64(3826)) ~ PARTIAL (14/61 points, 23.0%)
    → Overlap with predicted range (np.int64(3784), np.int64(3790)): 7 points
    → Overlap with predicted range (np.int64(3808), np.int64(3814)): 7 points
  Segment 3: (np.int64(5188), np.int64(5304)) ~ PARTIAL (50/117 points, 42.7%)
    → Overlap with predicted range (np.int64(5255), np.int64(5308)): 50 points
  Segment 4: (np.int64(5882), np.int64(5908)) ✓ FULL (27/27 points, 100.0%)
    → Overlap with predicted range (np.int64(5880), np.int64(5911)): 27 points
  Segment 5: (np.int64(6584), np.int64(6609)) ✓ FULL (26/26 points, 100.0%)
    → Overlap with predicted range (np.int64(6584), np.int64(6612)): 26 points
  Segment 6: (np.int64(7041), np.int64(7143)) ✓ FULL (103/103 points, 100.0%)
    → Overlap with predicted range (np.int64(7038), np.int64(7148)): 103 points
  Segment 7: (np.int64(7441), np.int64(7539)) ✓ FULL (99/99 points, 100.0%)
    → Overlap with predicted range (np.int64(7438), np.int64(7542)): 99 points
  Segment 8: (np.int64(9294), np.int64(9429)) ~ PARTIAL (70/136 points, 51.5%)
    → Overlap with predicted range (np.int64(9360), np.int64(9434)): 70 points
  Segment 9: (np.int64(9817), np.int64(9846)) ✓ FULL (30/30 points, 100.0%)
    → Overlap with predicted range (np.int64(9815), np.int64(9849)): 30 points

Basic Metrics:
  Accuracy:  0.9716
  Precision: 0.9060
  Recall:    0.7250
  F1-Score:  0.8055

Anomaly Statistics:
  True Anomalies: 811 points
  Predicted Anomalies: 649 points
  Detection Rate: 0.7250

Range-based Metrics:
  Range Precision: 0.7692
  Range Recall:    1.0000
  Range F1:        0.8696

Point-level Performance:
  True Positives:  588 points
  False Positives: 61 points
  False Negatives: 223 points

Segment Detection Metrics:
  Total Anomaly Segments: 10
  Fully Detected: 6
  Partially Detected: 4
  Missed: 0
  Segment Detection Rate: 0.6000
  Overall Detection Rate: 1.0000


================================================================================
Optimal contamination for precision: 0.0500
Detected 15 high-confidence anomaly ranges
Isolation Forest ranges: 18, Z-score ranges: 8
EVALUATION RESULTS - FILE 7
============================================================
Range Information:
  True Ranges: [(np.int64(2165), np.int64(2305)), (np.int64(2570), np.int64(2611)), (np.int64(4188), np.int64(4306)), (np.int64(4572), np.int64(4721)), (np.int64(5008), np.int64(5095)), (np.int64(6491), np.int64(6560)), (np.int64(7365), np.int64(7484)), (np.int64(8348), np.int64(8452)), (np.int64(8592), np.int64(8614)), (np.int64(9537), np.int64(9614))] (count: 10)
  Predicted Ranges: [(np.int64(0), np.int64(9)), (np.int64(2255), np.int64(2309)), (np.int64(2568), np.int64(2613)), (np.int64(4218), np.int64(4224)), (np.int64(4236), np.int64(4248)), (np.int64(4260), np.int64(4272)), (np.int64(4639), np.int64(4726)), (np.int64(5023), np.int64(5099)), (np.int64(6521), np.int64(6527)), (np.int64(7421), np.int64(7488)), (np.int64(8344), np.int64(8455)), (np.int64(8592), np.int64(8616)), (np.int64(9567), np.int64(9579)), (np.int64(9591), np.int64(9597)), (np.int64(9991), np.int64(9999))] (count: 15)

Detection Details by Segment:
  Segment 0: (np.int64(2165), np.int64(2305)) ~ PARTIAL (51/141 points, 36.2%)
    → Overlap with predicted range (np.int64(2255), np.int64(2309)): 51 points
  Segment 1: (np.int64(2570), np.int64(2611)) ✓ FULL (42/42 points, 100.0%)
    → Overlap with predicted range (np.int64(2568), np.int64(2613)): 42 points
  Segment 2: (np.int64(4188), np.int64(4306)) ~ PARTIAL (33/119 points, 27.7%)
    → Overlap with predicted range (np.int64(4218), np.int64(4224)): 7 points
    → Overlap with predicted range (np.int64(4236), np.int64(4248)): 13 points
    → Overlap with predicted range (np.int64(4260), np.int64(4272)): 13 points
  Segment 3: (np.int64(4572), np.int64(4721)) ~ PARTIAL (83/150 points, 55.3%)
    → Overlap with predicted range (np.int64(4639), np.int64(4726)): 83 points
  Segment 4: (np.int64(5008), np.int64(5095)) ✓ FULL (73/88 points, 83.0%)
    → Overlap with predicted range (np.int64(5023), np.int64(5099)): 73 points
  Segment 5: (np.int64(6491), np.int64(6560)) ~ PARTIAL (7/70 points, 10.0%)
    → Overlap with predicted range (np.int64(6521), np.int64(6527)): 7 points
  Segment 6: (np.int64(7365), np.int64(7484)) ~ PARTIAL (64/120 points, 53.3%)
    → Overlap with predicted range (np.int64(7421), np.int64(7488)): 64 points
  Segment 7: (np.int64(8348), np.int64(8452)) ✓ FULL (105/105 points, 100.0%)
    → Overlap with predicted range (np.int64(8344), np.int64(8455)): 105 points
  Segment 8: (np.int64(8592), np.int64(8614)) ✓ FULL (23/23 points, 100.0%)
    → Overlap with predicted range (np.int64(8592), np.int64(8616)): 23 points
  Segment 9: (np.int64(9537), np.int64(9614)) ~ PARTIAL (20/78 points, 25.6%)
    → Overlap with predicted range (np.int64(9567), np.int64(9579)): 13 points
    → Overlap with predicted range (np.int64(9591), np.int64(9597)): 7 points

Basic Metrics:
  Accuracy:  0.9516
  Precision: 0.9109
  Recall:    0.5353
  F1-Score:  0.6743

Anomaly Statistics:
  True Anomalies: 936 points
  Predicted Anomalies: 550 points
  Detection Rate: 0.5353

Range-based Metrics:
  Range Precision: 0.6667
  Range Recall:    1.0000
  Range F1:        0.8000

Point-level Performance:
  True Positives:  501 points
  False Positives: 49 points
  False Negatives: 435 points

Segment Detection Metrics:
  Total Anomaly Segments: 10
  Fully Detected: 4
  Partially Detected: 6
  Missed: 0
  Segment Detection Rate: 0.4000
  Overall Detection Rate: 1.0000


================================================================================
Optimal contamination for precision: 0.0500
Detected 14 high-confidence anomaly ranges
Isolation Forest ranges: 23, Z-score ranges: 9
EVALUATION RESULTS - FILE 8
============================================================
Range Information:
  True Ranges: [(np.int64(2340), np.int64(2407)), (np.int64(2594), np.int64(2698)), (np.int64(4708), np.int64(4787)), (np.int64(5387), np.int64(5480)), (np.int64(6153), np.int64(6267)), (np.int64(6479), np.int64(6580)), (np.int64(7548), np.int64(7569)), (np.int64(8021), np.int64(8058)), (np.int64(8299), np.int64(8329)), (np.int64(9827), np.int64(9904))] (count: 10)
  Predicted Ranges: [(np.int64(0), np.int64(9)), (np.int64(2346), np.int64(2352)), (np.int64(2364), np.int64(2400)), (np.int64(2633), np.int64(2700)), (np.int64(4741), np.int64(4789)), (np.int64(5418), np.int64(5482)), (np.int64(6159), np.int64(6165)), (np.int64(6177), np.int64(6267)), (np.int64(6495), np.int64(6582)), (np.int64(7544), np.int64(7574)), (np.int64(8019), np.int64(8059)), (np.int64(8295), np.int64(8335)), (np.int64(9833), np.int64(9900)), (np.int64(9990), np.int64(9999))] (count: 14)

Detection Details by Segment:
  Segment 0: (np.int64(2340), np.int64(2407)) ~ PARTIAL (44/68 points, 64.7%)
    → Overlap with predicted range (np.int64(2346), np.int64(2352)): 7 points
    → Overlap with predicted range (np.int64(2364), np.int64(2400)): 37 points
  Segment 1: (np.int64(2594), np.int64(2698)) ~ PARTIAL (66/105 points, 62.9%)
    → Overlap with predicted range (np.int64(2633), np.int64(2700)): 66 points
  Segment 2: (np.int64(4708), np.int64(4787)) ~ PARTIAL (47/80 points, 58.8%)
    → Overlap with predicted range (np.int64(4741), np.int64(4789)): 47 points
  Segment 3: (np.int64(5387), np.int64(5480)) ~ PARTIAL (63/94 points, 67.0%)
    → Overlap with predicted range (np.int64(5418), np.int64(5482)): 63 points
  Segment 4: (np.int64(6153), np.int64(6267)) ✓ FULL (98/115 points, 85.2%)
    → Overlap with predicted range (np.int64(6159), np.int64(6165)): 7 points
    → Overlap with predicted range (np.int64(6177), np.int64(6267)): 91 points
  Segment 5: (np.int64(6479), np.int64(6580)) ✓ FULL (86/102 points, 84.3%)
    → Overlap with predicted range (np.int64(6495), np.int64(6582)): 86 points
  Segment 6: (np.int64(7548), np.int64(7569)) ✓ FULL (22/22 points, 100.0%)
    → Overlap with predicted range (np.int64(7544), np.int64(7574)): 22 points
  Segment 7: (np.int64(8021), np.int64(8058)) ✓ FULL (38/38 points, 100.0%)
    → Overlap with predicted range (np.int64(8019), np.int64(8059)): 38 points
  Segment 8: (np.int64(8299), np.int64(8329)) ✓ FULL (31/31 points, 100.0%)
    → Overlap with predicted range (np.int64(8295), np.int64(8335)): 31 points
  Segment 9: (np.int64(9827), np.int64(9904)) ✓ FULL (68/78 points, 87.2%)
    → Overlap with predicted range (np.int64(9833), np.int64(9900)): 68 points

Basic Metrics:
  Accuracy:  0.9780
  Precision: 0.9184
  Recall:    0.7681
  F1-Score:  0.8366

Anomaly Statistics:
  True Anomalies: 733 points
  Predicted Anomalies: 613 points
  Detection Rate: 0.7681

Range-based Metrics:
  Range Precision: 0.7143
  Range Recall:    1.0000
  Range F1:        0.8333

Point-level Performance:
  True Positives:  563 points
  False Positives: 50 points
  False Negatives: 170 points

Segment Detection Metrics:
  Total Anomaly Segments: 10
  Fully Detected: 6
  Partially Detected: 4
  Missed: 0
  Segment Detection Rate: 0.6000
  Overall Detection Rate: 1.0000


================================================================================
Optimal contamination for precision: 0.0500
Detected 14 high-confidence anomaly ranges
Isolation Forest ranges: 28, Z-score ranges: 6
EVALUATION RESULTS - FILE 9
============================================================
Range Information:
  True Ranges: [(np.int64(3463), np.int64(3494)), (np.int64(3896), np.int64(3993)), (np.int64(4143), np.int64(4224)), (np.int64(5471), np.int64(5578)), (np.int64(6064), np.int64(6145)), (np.int64(6543), np.int64(6636)), (np.int64(7889), np.int64(8021)), (np.int64(8650), np.int64(8756)), (np.int64(9074), np.int64(9225)), (np.int64(9621), np.int64(9740))] (count: 10)
  Predicted Ranges: [(np.int64(0), np.int64(9)), (np.int64(3473), np.int64(3495)), (np.int64(3893), np.int64(3998)), (np.int64(4143), np.int64(4149)), (np.int64(4161), np.int64(4223)), (np.int64(5467), np.int64(5583)), (np.int64(6102), np.int64(6105)), (np.int64(6117), np.int64(6148)), (np.int64(6539), np.int64(6640)), (np.int64(7886), np.int64(8025)), (np.int64(8715), np.int64(8757)), (np.int64(9155), np.int64(9227)), (np.int64(9685), np.int64(9741)), (np.int64(9991), np.int64(9999))] (count: 14)

Detection Details by Segment:
  Segment 0: (np.int64(3463), np.int64(3494)) ~ PARTIAL (22/32 points, 68.8%)
    → Overlap with predicted range (np.int64(3473), np.int64(3495)): 22 points
  Segment 1: (np.int64(3896), np.int64(3993)) ✓ FULL (98/98 points, 100.0%)
    → Overlap with predicted range (np.int64(3893), np.int64(3998)): 98 points
  Segment 2: (np.int64(4143), np.int64(4224)) ✓ FULL (70/82 points, 85.4%)
    → Overlap with predicted range (np.int64(4143), np.int64(4149)): 7 points
    → Overlap with predicted range (np.int64(4161), np.int64(4223)): 63 points
  Segment 3: (np.int64(5471), np.int64(5578)) ✓ FULL (108/108 points, 100.0%)
    → Overlap with predicted range (np.int64(5467), np.int64(5583)): 108 points
  Segment 4: (np.int64(6064), np.int64(6145)) ~ PARTIAL (33/82 points, 40.2%)
    → Overlap with predicted range (np.int64(6102), np.int64(6105)): 4 points
    → Overlap with predicted range (np.int64(6117), np.int64(6148)): 29 points
  Segment 5: (np.int64(6543), np.int64(6636)) ✓ FULL (94/94 points, 100.0%)
    → Overlap with predicted range (np.int64(6539), np.int64(6640)): 94 points
  Segment 6: (np.int64(7889), np.int64(8021)) ✓ FULL (133/133 points, 100.0%)
    → Overlap with predicted range (np.int64(7886), np.int64(8025)): 133 points
  Segment 7: (np.int64(8650), np.int64(8756)) ~ PARTIAL (42/107 points, 39.3%)
    → Overlap with predicted range (np.int64(8715), np.int64(8757)): 42 points
  Segment 8: (np.int64(9074), np.int64(9225)) ~ PARTIAL (71/152 points, 46.7%)
    → Overlap with predicted range (np.int64(9155), np.int64(9227)): 71 points
  Segment 9: (np.int64(9621), np.int64(9740)) ~ PARTIAL (56/120 points, 46.7%)
    → Overlap with predicted range (np.int64(9685), np.int64(9741)): 56 points

Basic Metrics:
  Accuracy:  0.9660
  Precision: 0.9249
  Recall:    0.7212
  F1-Score:  0.8105

Anomaly Statistics:
  True Anomalies: 1008 points
  Predicted Anomalies: 786 points
  Detection Rate: 0.7212

Range-based Metrics:
  Range Precision: 0.7143
  Range Recall:    1.0000
  Range F1:        0.8333

Point-level Performance:
  True Positives:  727 points
  False Positives: 59 points
  False Negatives: 281 points

Segment Detection Metrics:
  Total Anomaly Segments: 10
  Fully Detected: 5
  Partially Detected: 5
  Missed: 0
  Segment Detection Rate: 0.5000
  Overall Detection Rate: 1.0000


================================================================================
OVERALL SUMMARY ACROSS ALL FILES - HIGH-PRECISION VERSION
================================================================================
Overall Basic Metrics:
  Accuracy:  0.9613
  Precision: 0.8845
  Recall:    0.6406
  F1-Score:  0.7365

Overall Range Statistics:
  Total True Ranges: 100
  Total Predicted Ranges: 160
  Total Matched Ranges: 100
  Range Match Rate: 1.0000

Overall Range-based Metrics:
  Range Precision: 0.6450
  Range Recall:    1.0000
  Range F1:        0.7785

Overall Point-level Performance:
  True Positives:  5350 points
  False Positives: 671 points
  False Negatives: 3197 points

Overall Segment Detection Metrics:
  Total Anomaly Segments: 100
  Fully Detected: 53
  Partially Detected: 47
  Missed: 0
  Segment Detection Rate: 0.5300
  Overall Detection Rate: 1.0000

================================================================================
FILE-BY-FILE SUMMARY - HIGH-PRECISION VERSION
================================================================================
File   Accuracy   Precision  Recall     F1-Score   True Ranges  Pred Ranges  Fully Det.   Part. Det.   Missed  
----------------------------------------------------------------------------------------------------
0      0.9498    0.8507     0.5303     0.6533     10          16          6           4           0       
1      0.9555    0.9249     0.6345     0.7526     10          16          5           5           0       
2      0.9612    0.8793     0.5855     0.7029     10          19          4           6           0       
3      0.9496    0.7885     0.5100     0.6193     10          20          5           5           0       
4      0.9874    0.8537     0.9075     0.8798     10          12          9           1           0       
5      0.9425    0.8879     0.4890     0.6307     10          21          3           7           0       
6      0.9716    0.9060     0.7250     0.8055     10          13          6           4           0       
7      0.9516    0.9109     0.5353     0.6743     10          15          4           6           0       
8      0.9780    0.9184     0.7681     0.8366     10          14          6           4           0       
9      0.9660    0.9249     0.7212     0.8105     10          14          5           5           0       
----------------------------------------------------------------------------------------------------

================================================================================
DETAILED RANGE INFORMATION BY FILE
================================================================================

File 0:
  True Ranges: [(np.int64(2533), np.int64(2620)), (np.int64(2864), np.int64(2949)), (np.int64(4811), np.int64(4910)), (np.int64(5148), np.int64(5304)), (np.int64(5492), np.int64(5619)), (np.int64(5986), np.int64(6016)), (np.int64(6222), np.int64(6257)), (np.int64(7088), np.int64(7117)), (np.int64(7599), np.int64(7716)), (np.int64(8633), np.int64(8750))] (count: 10)
  Predicted Ranges: [(np.int64(0), np.int64(9)), (np.int64(2533), np.int64(2617)), (np.int64(2860), np.int64(2954)), (np.int64(4808), np.int64(4817)), (np.int64(4900), np.int64(4912)), (np.int64(5236), np.int64(5245)), (np.int64(5291), np.int64(5308)), (np.int64(5491), np.int64(5503)), (np.int64(5608), np.int64(5624)), (np.int64(5982), np.int64(6017)), (np.int64(6219), np.int64(6258)), (np.int64(7084), np.int64(7122)), (np.int64(7595), np.int64(7613)), (np.int64(7711), np.int64(7718)), (np.int64(8628), np.int64(8756)), (np.int64(9986), np.int64(9999))] (count: 16)
  Matched Pairs:
    True Range 0 (np.int64(2533), np.int64(2620)) ↔ Predicted (np.int64(2533), np.int64(2617))
    True Range 1 (np.int64(2864), np.int64(2949)) ↔ Predicted (np.int64(2860), np.int64(2954))
    True Range 2 (np.int64(4811), np.int64(4910)) ↔ Predicted (np.int64(4808), np.int64(4817))
    True Range 3 (np.int64(5148), np.int64(5304)) ↔ Predicted (np.int64(5236), np.int64(5245))
    True Range 4 (np.int64(5492), np.int64(5619)) ↔ Predicted (np.int64(5491), np.int64(5503))
    True Range 5 (np.int64(5986), np.int64(6016)) ↔ Predicted (np.int64(5982), np.int64(6017))
    True Range 6 (np.int64(6222), np.int64(6257)) ↔ Predicted (np.int64(6219), np.int64(6258))
    True Range 7 (np.int64(7088), np.int64(7117)) ↔ Predicted (np.int64(7084), np.int64(7122))
    True Range 8 (np.int64(7599), np.int64(7716)) ↔ Predicted (np.int64(7595), np.int64(7613))
    True Range 9 (np.int64(8633), np.int64(8750)) ↔ Predicted (np.int64(8628), np.int64(8756))

File 1:
  True Ranges: [(np.int64(2206), np.int64(2325)), (np.int64(2864), np.int64(2978)), (np.int64(3483), np.int64(3565)), (np.int64(3834), np.int64(3926)), (np.int64(4758), np.int64(4878)), (np.int64(6850), np.int64(6957)), (np.int64(7852), np.int64(7954)), (np.int64(8319), np.int64(8428)), (np.int64(9112), np.int64(9225)), (np.int64(9372), np.int64(9471))] (count: 10)
  Predicted Ranges: [(np.int64(0), np.int64(9)), (np.int64(2205), np.int64(2327)), (np.int64(2930), np.int64(2981)), (np.int64(3482), np.int64(3567)), (np.int64(3830), np.int64(3931)), (np.int64(4757), np.int64(4882)), (np.int64(6856), np.int64(6862)), (np.int64(6904), np.int64(6910)), (np.int64(6928), np.int64(6934)), (np.int64(7901), np.int64(7906)), (np.int64(7918), np.int64(7959)), (np.int64(8377), np.int64(8430)), (np.int64(9160), np.int64(9166)), (np.int64(9184), np.int64(9190)), (np.int64(9391), np.int64(9476)), (np.int64(9990), np.int64(9999))] (count: 16)
  Matched Pairs:
    True Range 0 (np.int64(2206), np.int64(2325)) ↔ Predicted (np.int64(2205), np.int64(2327))
    True Range 1 (np.int64(2864), np.int64(2978)) ↔ Predicted (np.int64(2930), np.int64(2981))
    True Range 2 (np.int64(3483), np.int64(3565)) ↔ Predicted (np.int64(3482), np.int64(3567))
    True Range 3 (np.int64(3834), np.int64(3926)) ↔ Predicted (np.int64(3830), np.int64(3931))
    True Range 4 (np.int64(4758), np.int64(4878)) ↔ Predicted (np.int64(4757), np.int64(4882))
    True Range 5 (np.int64(6850), np.int64(6957)) ↔ Predicted (np.int64(6856), np.int64(6862))
    True Range 6 (np.int64(7852), np.int64(7954)) ↔ Predicted (np.int64(7901), np.int64(7906))
    True Range 7 (np.int64(8319), np.int64(8428)) ↔ Predicted (np.int64(8377), np.int64(8430))
    True Range 8 (np.int64(9112), np.int64(9225)) ↔ Predicted (np.int64(9160), np.int64(9166))
    True Range 9 (np.int64(9372), np.int64(9471)) ↔ Predicted (np.int64(9391), np.int64(9476))

File 2:
  True Ranges: [(np.int64(2657), np.int64(2755)), (np.int64(3755), np.int64(3860)), (np.int64(3991), np.int64(4011)), (np.int64(4429), np.int64(4558)), (np.int64(4968), np.int64(5070)), (np.int64(6624), np.int64(6713)), (np.int64(7931), np.int64(8008)), (np.int64(8129), np.int64(8159)), (np.int64(9307), np.int64(9393)), (np.int64(9752), np.int64(9790))] (count: 10)
  Predicted Ranges: [(np.int64(0), np.int64(9)), (np.int64(2681), np.int64(2687)), (np.int64(2699), np.int64(2711)), (np.int64(2729), np.int64(2735)), (np.int64(2747), np.int64(2755)), (np.int64(3761), np.int64(3767)), (np.int64(3785), np.int64(3791)), (np.int64(3803), np.int64(3815)), (np.int64(3833), np.int64(3839)), (np.int64(3988), np.int64(4013)), (np.int64(4487), np.int64(4562)), (np.int64(4964), np.int64(5075)), (np.int64(6655), np.int64(6718)), (np.int64(7961), np.int64(7967)), (np.int64(7979), np.int64(7991)), (np.int64(8126), np.int64(8163)), (np.int64(9350), np.int64(9397)), (np.int64(9749), np.int64(9795)), (np.int64(9989), np.int64(9999))] (count: 19)
  Matched Pairs:
    True Range 0 (np.int64(2657), np.int64(2755)) ↔ Predicted (np.int64(2681), np.int64(2687))
    True Range 1 (np.int64(3755), np.int64(3860)) ↔ Predicted (np.int64(3761), np.int64(3767))
    True Range 2 (np.int64(3991), np.int64(4011)) ↔ Predicted (np.int64(3988), np.int64(4013))
    True Range 3 (np.int64(4429), np.int64(4558)) ↔ Predicted (np.int64(4487), np.int64(4562))
    True Range 4 (np.int64(4968), np.int64(5070)) ↔ Predicted (np.int64(4964), np.int64(5075))
    True Range 5 (np.int64(6624), np.int64(6713)) ↔ Predicted (np.int64(6655), np.int64(6718))
    True Range 6 (np.int64(7931), np.int64(8008)) ↔ Predicted (np.int64(7961), np.int64(7967))
    True Range 7 (np.int64(8129), np.int64(8159)) ↔ Predicted (np.int64(8126), np.int64(8163))
    True Range 8 (np.int64(9307), np.int64(9393)) ↔ Predicted (np.int64(9350), np.int64(9397))
    True Range 9 (np.int64(9752), np.int64(9790)) ↔ Predicted (np.int64(9749), np.int64(9795))

File 3:
  True Ranges: [(np.int64(2240), np.int64(2338)), (np.int64(2824), np.int64(2912)), (np.int64(3685), np.int64(3792)), (np.int64(4212), np.int64(4244)), (np.int64(5007), np.int64(5029)), (np.int64(5758), np.int64(5870)), (np.int64(6665), np.int64(6777)), (np.int64(8492), np.int64(8521)), (np.int64(9099), np.int64(9197)), (np.int64(9628), np.int64(9724))] (count: 10)
  Predicted Ranges: [(np.int64(0), np.int64(24)), (np.int64(2282), np.int64(2291)), (np.int64(2334), np.int64(2342)), (np.int64(2824), np.int64(2909)), (np.int64(3681), np.int64(3689)), (np.int64(3732), np.int64(3744)), (np.int64(3787), np.int64(3797)), (np.int64(4210), np.int64(4248)), (np.int64(5003), np.int64(5034)), (np.int64(5755), np.int64(5762)), (np.int64(5804), np.int64(5824)), (np.int64(5865), np.int64(5874)), (np.int64(6661), np.int64(6678)), (np.int64(6713), np.int64(6729)), (np.int64(6772), np.int64(6781)), (np.int64(8486), np.int64(8527)), (np.int64(9137), np.int64(9155)), (np.int64(9184), np.int64(9202)), (np.int64(9628), np.int64(9725)), (np.int64(9976), np.int64(9999))] (count: 20)
  Matched Pairs:
    True Range 0 (np.int64(2240), np.int64(2338)) ↔ Predicted (np.int64(2282), np.int64(2291))
    True Range 1 (np.int64(2824), np.int64(2912)) ↔ Predicted (np.int64(2824), np.int64(2909))
    True Range 2 (np.int64(3685), np.int64(3792)) ↔ Predicted (np.int64(3681), np.int64(3689))
    True Range 3 (np.int64(4212), np.int64(4244)) ↔ Predicted (np.int64(4210), np.int64(4248))
    True Range 4 (np.int64(5007), np.int64(5029)) ↔ Predicted (np.int64(5003), np.int64(5034))
    True Range 5 (np.int64(5758), np.int64(5870)) ↔ Predicted (np.int64(5755), np.int64(5762))
    True Range 6 (np.int64(6665), np.int64(6777)) ↔ Predicted (np.int64(6661), np.int64(6678))
    True Range 7 (np.int64(8492), np.int64(8521)) ↔ Predicted (np.int64(8486), np.int64(8527))
    True Range 8 (np.int64(9099), np.int64(9197)) ↔ Predicted (np.int64(9137), np.int64(9155))
    True Range 9 (np.int64(9628), np.int64(9724)) ↔ Predicted (np.int64(9628), np.int64(9725))

File 4:
  True Ranges: [(np.int64(2229), np.int64(2272)), (np.int64(2744), np.int64(2840)), (np.int64(3010), np.int64(3034)), (np.int64(3761), np.int64(3783)), (np.int64(5028), np.int64(5065)), (np.int64(6270), np.int64(6304)), (np.int64(8383), np.int64(8422)), (np.int64(8650), np.int64(8730)), (np.int64(9602), np.int64(9627)), (np.int64(9862), np.int64(9960))] (count: 10)
  Predicted Ranges: [(np.int64(0), np.int64(9)), (np.int64(2225), np.int64(2276)), (np.int64(2740), np.int64(2845)), (np.int64(3008), np.int64(3038)), (np.int64(3759), np.int64(3786)), (np.int64(5025), np.int64(5068)), (np.int64(6267), np.int64(6305)), (np.int64(8380), np.int64(8427)), (np.int64(8685), np.int64(8735)), (np.int64(9599), np.int64(9632)), (np.int64(9874), np.int64(9960)), (np.int64(9990), np.int64(9999))] (count: 12)
  Matched Pairs:
    True Range 0 (np.int64(2229), np.int64(2272)) ↔ Predicted (np.int64(2225), np.int64(2276))
    True Range 1 (np.int64(2744), np.int64(2840)) ↔ Predicted (np.int64(2740), np.int64(2845))
    True Range 2 (np.int64(3010), np.int64(3034)) ↔ Predicted (np.int64(3008), np.int64(3038))
    True Range 3 (np.int64(3761), np.int64(3783)) ↔ Predicted (np.int64(3759), np.int64(3786))
    True Range 4 (np.int64(5028), np.int64(5065)) ↔ Predicted (np.int64(5025), np.int64(5068))
    True Range 5 (np.int64(6270), np.int64(6304)) ↔ Predicted (np.int64(6267), np.int64(6305))
    True Range 6 (np.int64(8383), np.int64(8422)) ↔ Predicted (np.int64(8380), np.int64(8427))
    True Range 7 (np.int64(8650), np.int64(8730)) ↔ Predicted (np.int64(8685), np.int64(8735))
    True Range 8 (np.int64(9602), np.int64(9627)) ↔ Predicted (np.int64(9599), np.int64(9632))
    True Range 9 (np.int64(9862), np.int64(9960)) ↔ Predicted (np.int64(9874), np.int64(9960))

File 5:
  True Ranges: [(np.int64(2661), np.int64(2775)), (np.int64(2863), np.int64(2894)), (np.int64(3006), np.int64(3124)), (np.int64(4118), np.int64(4269)), (np.int64(4463), np.int64(4591)), (np.int64(5953), np.int64(5994)), (np.int64(6107), np.int64(6225)), (np.int64(6429), np.int64(6577)), (np.int64(7969), np.int64(8094)), (np.int64(8886), np.int64(8906))] (count: 10)
  Predicted Ranges: [(np.int64(0), np.int64(9)), (np.int64(2679), np.int64(2685)), (np.int64(2703), np.int64(2715)), (np.int64(2727), np.int64(2733)), (np.int64(2863), np.int64(2897)), (np.int64(3004), np.int64(3010)), (np.int64(3056), np.int64(3075)), (np.int64(3121), np.int64(3127)), (np.int64(4180), np.int64(4274)), (np.int64(4463), np.int64(4466)), (np.int64(4513), np.int64(4542)), (np.int64(4588), np.int64(4594)), (np.int64(5950), np.int64(5998)), (np.int64(6137), np.int64(6167)), (np.int64(6179), np.int64(6215)), (np.int64(6484), np.int64(6581)), (np.int64(7968), np.int64(7979)), (np.int64(8019), np.int64(8045)), (np.int64(8083), np.int64(8098)), (np.int64(8885), np.int64(8909)), (np.int64(9984), np.int64(9999))] (count: 21)
  Matched Pairs:
    True Range 0 (np.int64(2661), np.int64(2775)) ↔ Predicted (np.int64(2679), np.int64(2685))
    True Range 1 (np.int64(2863), np.int64(2894)) ↔ Predicted (np.int64(2863), np.int64(2897))
    True Range 2 (np.int64(3006), np.int64(3124)) ↔ Predicted (np.int64(3004), np.int64(3010))
    True Range 3 (np.int64(4118), np.int64(4269)) ↔ Predicted (np.int64(4180), np.int64(4274))
    True Range 4 (np.int64(4463), np.int64(4591)) ↔ Predicted (np.int64(4463), np.int64(4466))
    True Range 5 (np.int64(5953), np.int64(5994)) ↔ Predicted (np.int64(5950), np.int64(5998))
    True Range 6 (np.int64(6107), np.int64(6225)) ↔ Predicted (np.int64(6137), np.int64(6167))
    True Range 7 (np.int64(6429), np.int64(6577)) ↔ Predicted (np.int64(6484), np.int64(6581))
    True Range 8 (np.int64(7969), np.int64(8094)) ↔ Predicted (np.int64(7968), np.int64(7979))
    True Range 9 (np.int64(8886), np.int64(8906)) ↔ Predicted (np.int64(8885), np.int64(8909))

File 6:
  True Ranges: [(np.int64(2543), np.int64(2670)), (np.int64(3004), np.int64(3087)), (np.int64(3766), np.int64(3826)), (np.int64(5188), np.int64(5304)), (np.int64(5882), np.int64(5908)), (np.int64(6584), np.int64(6609)), (np.int64(7041), np.int64(7143)), (np.int64(7441), np.int64(7539)), (np.int64(9294), np.int64(9429)), (np.int64(9817), np.int64(9846))] (count: 10)
  Predicted Ranges: [(np.int64(0), np.int64(9)), (np.int64(2541), np.int64(2672)), (np.int64(3047), np.int64(3089)), (np.int64(3784), np.int64(3790)), (np.int64(3808), np.int64(3814)), (np.int64(5255), np.int64(5308)), (np.int64(5880), np.int64(5911)), (np.int64(6584), np.int64(6612)), (np.int64(7038), np.int64(7148)), (np.int64(7438), np.int64(7542)), (np.int64(9360), np.int64(9434)), (np.int64(9815), np.int64(9849)), (np.int64(9991), np.int64(9999))] (count: 13)
  Matched Pairs:
    True Range 0 (np.int64(2543), np.int64(2670)) ↔ Predicted (np.int64(2541), np.int64(2672))
    True Range 1 (np.int64(3004), np.int64(3087)) ↔ Predicted (np.int64(3047), np.int64(3089))
    True Range 2 (np.int64(3766), np.int64(3826)) ↔ Predicted (np.int64(3784), np.int64(3790))
    True Range 3 (np.int64(5188), np.int64(5304)) ↔ Predicted (np.int64(5255), np.int64(5308))
    True Range 4 (np.int64(5882), np.int64(5908)) ↔ Predicted (np.int64(5880), np.int64(5911))
    True Range 5 (np.int64(6584), np.int64(6609)) ↔ Predicted (np.int64(6584), np.int64(6612))
    True Range 6 (np.int64(7041), np.int64(7143)) ↔ Predicted (np.int64(7038), np.int64(7148))
    True Range 7 (np.int64(7441), np.int64(7539)) ↔ Predicted (np.int64(7438), np.int64(7542))
    True Range 8 (np.int64(9294), np.int64(9429)) ↔ Predicted (np.int64(9360), np.int64(9434))
    True Range 9 (np.int64(9817), np.int64(9846)) ↔ Predicted (np.int64(9815), np.int64(9849))

File 7:
  True Ranges: [(np.int64(2165), np.int64(2305)), (np.int64(2570), np.int64(2611)), (np.int64(4188), np.int64(4306)), (np.int64(4572), np.int64(4721)), (np.int64(5008), np.int64(5095)), (np.int64(6491), np.int64(6560)), (np.int64(7365), np.int64(7484)), (np.int64(8348), np.int64(8452)), (np.int64(8592), np.int64(8614)), (np.int64(9537), np.int64(9614))] (count: 10)
  Predicted Ranges: [(np.int64(0), np.int64(9)), (np.int64(2255), np.int64(2309)), (np.int64(2568), np.int64(2613)), (np.int64(4218), np.int64(4224)), (np.int64(4236), np.int64(4248)), (np.int64(4260), np.int64(4272)), (np.int64(4639), np.int64(4726)), (np.int64(5023), np.int64(5099)), (np.int64(6521), np.int64(6527)), (np.int64(7421), np.int64(7488)), (np.int64(8344), np.int64(8455)), (np.int64(8592), np.int64(8616)), (np.int64(9567), np.int64(9579)), (np.int64(9591), np.int64(9597)), (np.int64(9991), np.int64(9999))] (count: 15)
  Matched Pairs:
    True Range 0 (np.int64(2165), np.int64(2305)) ↔ Predicted (np.int64(2255), np.int64(2309))
    True Range 1 (np.int64(2570), np.int64(2611)) ↔ Predicted (np.int64(2568), np.int64(2613))
    True Range 2 (np.int64(4188), np.int64(4306)) ↔ Predicted (np.int64(4218), np.int64(4224))
    True Range 3 (np.int64(4572), np.int64(4721)) ↔ Predicted (np.int64(4639), np.int64(4726))
    True Range 4 (np.int64(5008), np.int64(5095)) ↔ Predicted (np.int64(5023), np.int64(5099))
    True Range 5 (np.int64(6491), np.int64(6560)) ↔ Predicted (np.int64(6521), np.int64(6527))
    True Range 6 (np.int64(7365), np.int64(7484)) ↔ Predicted (np.int64(7421), np.int64(7488))
    True Range 7 (np.int64(8348), np.int64(8452)) ↔ Predicted (np.int64(8344), np.int64(8455))
    True Range 8 (np.int64(8592), np.int64(8614)) ↔ Predicted (np.int64(8592), np.int64(8616))
    True Range 9 (np.int64(9537), np.int64(9614)) ↔ Predicted (np.int64(9567), np.int64(9579))

File 8:
  True Ranges: [(np.int64(2340), np.int64(2407)), (np.int64(2594), np.int64(2698)), (np.int64(4708), np.int64(4787)), (np.int64(5387), np.int64(5480)), (np.int64(6153), np.int64(6267)), (np.int64(6479), np.int64(6580)), (np.int64(7548), np.int64(7569)), (np.int64(8021), np.int64(8058)), (np.int64(8299), np.int64(8329)), (np.int64(9827), np.int64(9904))] (count: 10)
  Predicted Ranges: [(np.int64(0), np.int64(9)), (np.int64(2346), np.int64(2352)), (np.int64(2364), np.int64(2400)), (np.int64(2633), np.int64(2700)), (np.int64(4741), np.int64(4789)), (np.int64(5418), np.int64(5482)), (np.int64(6159), np.int64(6165)), (np.int64(6177), np.int64(6267)), (np.int64(6495), np.int64(6582)), (np.int64(7544), np.int64(7574)), (np.int64(8019), np.int64(8059)), (np.int64(8295), np.int64(8335)), (np.int64(9833), np.int64(9900)), (np.int64(9990), np.int64(9999))] (count: 14)
  Matched Pairs:
    True Range 0 (np.int64(2340), np.int64(2407)) ↔ Predicted (np.int64(2346), np.int64(2352))
    True Range 1 (np.int64(2594), np.int64(2698)) ↔ Predicted (np.int64(2633), np.int64(2700))
    True Range 2 (np.int64(4708), np.int64(4787)) ↔ Predicted (np.int64(4741), np.int64(4789))
    True Range 3 (np.int64(5387), np.int64(5480)) ↔ Predicted (np.int64(5418), np.int64(5482))
    True Range 4 (np.int64(6153), np.int64(6267)) ↔ Predicted (np.int64(6159), np.int64(6165))
    True Range 5 (np.int64(6479), np.int64(6580)) ↔ Predicted (np.int64(6495), np.int64(6582))
    True Range 6 (np.int64(7548), np.int64(7569)) ↔ Predicted (np.int64(7544), np.int64(7574))
    True Range 7 (np.int64(8021), np.int64(8058)) ↔ Predicted (np.int64(8019), np.int64(8059))
    True Range 8 (np.int64(8299), np.int64(8329)) ↔ Predicted (np.int64(8295), np.int64(8335))
    True Range 9 (np.int64(9827), np.int64(9904)) ↔ Predicted (np.int64(9833), np.int64(9900))

File 9:
  True Ranges: [(np.int64(3463), np.int64(3494)), (np.int64(3896), np.int64(3993)), (np.int64(4143), np.int64(4224)), (np.int64(5471), np.int64(5578)), (np.int64(6064), np.int64(6145)), (np.int64(6543), np.int64(6636)), (np.int64(7889), np.int64(8021)), (np.int64(8650), np.int64(8756)), (np.int64(9074), np.int64(9225)), (np.int64(9621), np.int64(9740))] (count: 10)
  Predicted Ranges: [(np.int64(0), np.int64(9)), (np.int64(3473), np.int64(3495)), (np.int64(3893), np.int64(3998)), (np.int64(4143), np.int64(4149)), (np.int64(4161), np.int64(4223)), (np.int64(5467), np.int64(5583)), (np.int64(6102), np.int64(6105)), (np.int64(6117), np.int64(6148)), (np.int64(6539), np.int64(6640)), (np.int64(7886), np.int64(8025)), (np.int64(8715), np.int64(8757)), (np.int64(9155), np.int64(9227)), (np.int64(9685), np.int64(9741)), (np.int64(9991), np.int64(9999))] (count: 14)
  Matched Pairs:
    True Range 0 (np.int64(3463), np.int64(3494)) ↔ Predicted (np.int64(3473), np.int64(3495))
    True Range 1 (np.int64(3896), np.int64(3993)) ↔ Predicted (np.int64(3893), np.int64(3998))
    True Range 2 (np.int64(4143), np.int64(4224)) ↔ Predicted (np.int64(4143), np.int64(4149))
    True Range 3 (np.int64(5471), np.int64(5578)) ↔ Predicted (np.int64(5467), np.int64(5583))
    True Range 4 (np.int64(6064), np.int64(6145)) ↔ Predicted (np.int64(6102), np.int64(6105))
    True Range 5 (np.int64(6543), np.int64(6636)) ↔ Predicted (np.int64(6539), np.int64(6640))
    True Range 6 (np.int64(7889), np.int64(8021)) ↔ Predicted (np.int64(7886), np.int64(8025))
    True Range 7 (np.int64(8650), np.int64(8756)) ↔ Predicted (np.int64(8715), np.int64(8757))
    True Range 8 (np.int64(9074), np.int64(9225)) ↔ Predicted (np.int64(9155), np.int64(9227))
    True Range 9 (np.int64(9621), np.int64(9740)) ↔ Predicted (np.int64(9685), np.int64(9741))

Evaluation completed for all files with high-precision detection methods!</code></pre>
</div>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/AlexTabble\.github\.io\/EDAB2724_AnomalyDetection\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>